<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type"><title>Chapter 2. Overview of Commands and Routines</title><meta name="generator" content="DocBook XSL Stylesheets V1.49"><meta name="generator" content="SGI XSL DocBook Customization Stylesheets V1.0"><link rel="home" href="index.html" title="OpenGL Reference Manual (Addison-Wesley Publishing Company)"><link rel="up" href="bk02.html" title="OpenGL Reference Manual"><link rel="previous" href="ch01.html" title="Chapter 1. Introduction to OpenGL"><link rel="next" href="ch03.html" title="Chapter 3. Summary of Commands and Routines"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 2. Overview of Commands and Routines</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch01.html">Prev</a> </td><th width="60%" align="center">OpenGL Reference Manual</th><td width="20%" align="right"> <a accesskey="n" href="ch03.html">Next</a></td></tr></table><hr></div><!--CONTENT_BEGIN--><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="id5363373"></a>Chapter 2. <a name="id51876"></a>Overview of Commands and Routines</h2></div></div>
<p>Many OpenGL commands pertain specifically to drawing objects such as points, lines, polygons, and bitmaps. Other commands control the way that some of this drawing occurs (such as those that enable antialiasing or texturing). Still other commands are specifically concerned with frame buffer manipulation. This chapter briefly describes how all the OpenGL commands work together to create the OpenGL processing pipeline. Brief overviews are also given of the routines comprising the OpenGL Utility Library (GLU) and the OpenGL extensions to the X Window System (GLX). </p>
<p>This chapter has the following main sections:</p>
<div class="itemizedlist"><ul type="disc"><li><p><a href="ch02.html#id57691">&quot;OpenGL Processing Pipeline&quot;</a>
 expands on the discussion in <a href="ch01.html#id60402">Chapter 1</a>
 by explaining how specific OpenGL commands control the processing of data.</p>
</li>
<li><p><a href="ch02.html#id23039">&quot;Additional OpenGL Commands&quot;</a>
 discusses several sets of OpenGL commands not covered in the previous section.</p>
</li>
<li><p><a href="ch02.html#id24847">&quot;OpenGL Utility Library&quot;</a>
 describes the GLU routines that are available.</p>
</li>
<li><p><a href="ch02.html#id86751">&quot;OpenGL Extension to the X Window System&quot;</a>
 describes the GLX routines.</p>
</li>
</ul></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5363512"></a><a name="id57691"></a>OpenGL Processing Pipeline</h2></div></div>
<p>Now that you have a general idea of how OpenGL works from <a href="ch01.html#id60402">Chapter 1</a>
, let's take a closer look at the stages in which data is actually processed and tie these stages to OpenGL commands. The figure shown on the next page is a more detailed block diagram of the OpenGL processing pipeline. </p>
<p>For most of the pipeline, you can see three vertical arrows between the major stages. These arrows represent vertices and the two primary types of data that can be associated with vertices: color values and texture coordinates. Also note that vertices are assembled into primitives, then to fragments, and finally to pixels in the frame buffer. This progression is discussed in more detail in the following sections. </p>
<p>As you continue reading, be aware that we've taken some liberties with command names. Many OpenGL commands are simple variations of each other, differing mostly in the data type of arguments; some commands differ in the number of related arguments and whether those arguments can be specified as a vector or whether they must be specified separately in a list. For example, if you use the <tt>glVertex2f()</tt> command, you need to supply <tt>x</tt> and <tt>y</tt> coordinates as 32-bit floating-point numbers; with <tt>glVertex3sv()</tt>, you must supply an array of three short (16-bit) integer values for <tt>x</tt>, <tt>y</tt>, and <tt>z</tt>. For simplicity, only the base name of the command is used in the discussion that follows, and an asterisk is included to indicate that there may be more to the actual command name than is being shown. For example, <tt>glVertex*()</tt> stands for all variations of the command you use to specify vertices. </p>
<p>Also keep in mind that the effect of an OpenGL command may vary depending on whether certain modes are enabled. For example, you need to enable lighting if the lighting-related commands are to have the desired effect of producing a properly lit object. To enable a particular mode, you use the <tt>glEnable()</tt> command and supply the appropriate constant to identify the mode (for example, GL_LIGHTING). The following sections don't discuss specific modes, but you can refer to the reference page for <tt>glEnable()</tt> for a complete list of the modes that can be enabled. Modes are disabled with <tt>glDisable()</tt>. </p>
<p><div class="figure"><p><a name="id5363665"></a><b>Figure 2-1. 
OpenGL Pipeline</b></p>
<div class="mediaobject"><img src="figures/OpenGLPipeline.gif" height="661" width="493"></div></div><br>
</p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5363678"></a>Vertices</h3></div></div>
<p>This section relates the OpenGL commands that perform per-vertex operations to the processing stages shown in the figure on the previous page.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5363689"></a>Input Data</h4></div></div>
<p>You must provide several types of input data to the OpenGL pipeline:</p>
<div class="itemizedlist"><ul type="disc"><li><p>Vertices&#8212;Vertices describe the shape of the desired geometric object. To specify vertices, you use <tt>glVertex*()</tt> commands in conjunction with <tt>glBegin()</tt> and <tt>glEnd()</tt> to create a point, line, or polygon. You can also use <tt>glRect*()</tt> to describe an entire rectangle at once. </p>
</li>
<li><p>Edge flag&#8212;By default, all edges of polygons are boundary edges. Use the <tt>glEdgeFlag*()</tt> command to explicitly set the edge flag. </p>
</li>
<li><p>Current raster position&#8212;Specified with <tt>glRasterPos*()</tt>, the current raster position is used to determine raster coordinates for pixel and bitmap drawing operations. </p>
</li>
<li><p>Current normal&#8212;A normal vector associated with a particular vertex determines how a surface at that vertex is oriented in three-dimensional space; this in turn affects how much light that particular vertex receives. Use <tt>glNormal*()</tt> to specify a normal vector. </p>
</li>
<li><p>Current color&#8212;The color of a vertex, together with the lighting conditions, determine the final, lit color. Color is specified with <tt>glColor*()</tt> if in RGBA mode or with <tt>glIndex*()</tt> if in color index mode. </p>
</li>
<li><p>Current texture coordinates&#8212;Specified with <tt>glTexCoord*()</tt>, texture coordinates determine the location in a texture map that should be associated with a vertex of an object.</p>
</li>
</ul></div><p>When <tt>glVertex*()</tt> is called, the resulting vertex inherits the current edge flag, normal, color, and texture coordinates. Therefore, <tt>glEdgeFlag*()</tt>, <tt>glNormal*()</tt>, <tt>glColor*()</tt>, and <tt>glTexCoord*()</tt> must be called before <tt>glVertex*()</tt> if they are to affect the resulting vertex. </p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5363907"></a>Matrix Transformations</h4></div></div>
<p>Vertices and normals are transformed by the modelview and projection matrices before they're used to produce an image in the frame buffer. You can use commands such as <tt>glMatrixMode()</tt>, <tt>glMultMatrix()</tt>, <tt>glRotate()</tt>, <tt>glTranslate()</tt>, and <tt>glScale()</tt> to compose the desired transformations, or you can directly specify matrices with <tt>glLoadMatrix()</tt> and <tt>glLoadIdentity()</tt>. Use <tt>glPushMatrix()</tt> and <tt>glPopMatrix()</tt> to save and restore modelview and projection matrices on their respective stacks. </p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5363967"></a>Lighting and Coloring</h4></div></div>
<p>In addition to specifying colors and normal vectors, you may define the desired lighting conditions with <tt>glLight*()</tt> and <tt>glLightModel*()</tt>, and the desired material properties with <tt>glMaterial*()</tt>. Related commands you might use to control how lighting calculations are performed include <tt>glShadeModel()</tt>, <tt>glFrontFace()</tt>, and <tt>glColorMaterial()</tt>. </p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5364039"></a>Generating Texture Coordinates</h4></div></div>
<p>Rather than explicitly supplying texture coordinates, you can have OpenGL generate them as a function of other vertex data. This is what the <tt>glTexGen*()</tt> command does. After the texture coordinates have been specified or generated, they are transformed by the texture matrix. This matrix is controlled with the same commands mentioned earlier for matrix transformations. </p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5364060"></a>Primitive Assembly</h4></div></div>
<p>Once all these calculations have been performed, vertices are assembled into primitives&#8212;points, line segments, or polygons&#8212;together with the relevant edge flag, color, and texture information for each vertex.</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5364080"></a>Primitives</h3></div></div>
<p>During the next stage of processing, primitives are converted to pixel fragments in several steps: primitives are clipped appropriately, whatever corresponding adjustments are necessary are made to the color and texture data, and the relevant coordinates are transformed to window coordinates. Finally, rasterization converts the clipped primitives to pixel fragments. </p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5364095"></a>Clipping</h4></div></div>
<p>Points, line segments, and polygons are handled slightly differently during clipping. Points are either retained in their original state (if they're inside the clip volume) or discarded (if they're outside). If portions of line segments or polygons are outside the clip volume, new vertices are generated at the clip points. For polygons, an entire edge may need to be constructed between such new vertices. For both line segments and polygons that are clipped, the edge flag, color, and texture information is assigned to all new vertices.</p>
<p>Clipping actually happens in two steps: </p>
<div class="orderedlist"><ol type="1"><li><p>Application-specific clipping&#8212;Immediately after primitives are assembled, they're clipped in <i>eye coordinates</i> as necessary for any arbitrary clipping planes you've defined for your application with <tt>glClipPlane()</tt>. (OpenGL requires support for at least six such application-specific clipping planes.)</p>
</li>
<li><p>View volume clipping&#8212;Next, primitives are transformed by the projection matrix (into <i>clip coordinates</i>) and clipped by the corresponding viewing volume. This matrix can be controlled by the previously mentioned matrix transformation commands but is most typically specified by <tt>glFrustum()</tt> or <tt>glOrtho()</tt>. </p>
</li>
</ol></div></div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5364194"></a>Transforming to Window Coordinates</h4></div></div>
<p>Before clip coordinates can be converted to <i>window coordinates</i>, they are normalized by dividing by the value of <tt>w</tt> to yield <i>normalized device coordinates</i>. After that, the viewport transformation applied to these normalized coordinates produces window coordinates. You control the viewport, which determines the area of the on-screen window that displays an image, with <tt>glDepthRange()</tt> and <tt>glViewport()</tt>. </p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5362126"></a>Rasterization</h4></div></div>
<p>Rasterization is the process by which a primitive is converted to a two-dimensional image. Each point of this image contains such information as color, depth, and texture data. Together, a point and its associated information are called a <i>fragment</i>. The current raster position (as specified with <tt>glRasterPos*()</tt>) is used in various ways during this stage for pixel drawing and bitmaps. As discussed below, different issues arise when rasterizing the three different types of primitives; in addition, pixel rectangles and bitmaps need to be rasterized. </p>
<p><span class="bold"><b>Primitives.</b></span> You control how primitives are rasterized with commands that allow you to choose dimensions and stipple patterns: <tt>glPointSize()</tt>, <tt>glLineWidth()</tt>, <tt>glLineStipple()</tt>, and <tt>glPolygonStipple()</tt>. Additionally, you can control how the front and back faces of polygons are rasterized with <tt>glCullFace()</tt>, <tt>glFrontFace()</tt>, and <tt>glPolygonMode()</tt>. </p>
<p><span class="bold"><b>Pixels.</b></span> Several commands control pixel storage and transfer modes. The command <tt>glPixelStore*()</tt> controls the encoding of pixels in client memory, and <tt>glPixelTransfer*()</tt> and <tt>glPixelMap*()</tt> control how pixels are processed before being placed in the frame buffer. A pixel rectangle is specified with <tt>glDrawPixels()</tt>; its rasterization is controlled with <tt>glPixelZoom()</tt>. </p>
<p><span class="bold"><b>Bitmaps.</b></span> Bitmaps are rectangles of zeros and ones specifying a particular pattern of fragments to be produced. Each of these fragments has the same associated data. A bitmap is specified using <tt>glBitmap()</tt>.</p>
<p><span class="bold"><b>Texture Memory.</b></span> Texturing maps a portion of a specified texture image onto each primitive when texturing is enabled. This mapping is accomplished by using the color of the texture image at the location indicated by a fragment's texture coordinates to modify the fragment's RGBA color. A texture image is specified using <tt>glTexImage2D()</tt> or <tt>glTexImage1D()</tt>. The commands <tt>glTexParameter*()</tt> and <tt>glTexEnv*()</tt> control how texture values are interpreted and applied to a fragment.</p>
<p><span class="bold"><b>Fog.</b></span> You can have OpenGL blend a fog color with a rasterized fragment's post-texturing color using a blending factor that depends on the distance between the eyepoint and the fragment. Use <tt>glFog*()</tt> to specify the fog color and blending factor.</p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5362360"></a>Fragments</h3></div></div>
<p>OpenGL allows a fragment produced by rasterization to modify the corresponding pixel in the frame buffer only if it passes a series of tests. If it does pass, the fragment's data can be used directly to replace the existing frame buffer values, or it can be combined with existing data in the frame buffer, depending on the state of certain modes.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5362374"></a>Pixel Ownership Test</h4></div></div>
<p>The first test is to determine whether the pixel in the frame buffer corresponding to a particular fragment is owned by the current OpenGL context. If so, the fragment proceeds to the next test. If not, the window system determines whether the fragment is discarded or whether any further fragment operations will be performed with that fragment. This test allows the window system to control OpenGL's behavior when, for example, an OpenGL window is obscured.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5362392"></a>Scissor Test</h4></div></div>
<p>With the <tt>glScissor()</tt> command, you can specify an arbitrary screen-aligned rectangle outside of which fragments will be discarded.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5362408"></a>Alpha Test</h4></div></div>
<p>The alpha test (which is performed only in RGBA mode) discards a fragment depending on the outcome of a comparison between the fragment's alpha value and a constant reference value. The comparison command and reference value are specified with <tt>glAlphaFunc()</tt>.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5362426"></a>Stencil Test</h4></div></div>
<p>The stencil test conditionally discards a fragment based on the outcome of a comparison between the value in the stencil buffer and a reference value. The command <tt>glStencilFunc()</tt> specifies the comparison command and the reference value. Whether the fragment passes or fails the stencil test, the value in the stencil buffer is modified according to the instructions specified with <tt>glStencilOp()</tt>.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5361959"></a>Depth Buffer Test</h4></div></div>
<p>The depth buffer test discards a fragment if a depth comparison fails; <tt>glDepthFunc()</tt> specifies the comparison command. The result of the depth comparison also affects the stencil buffer update value if stenciling is enabled. </p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5362007"></a>Blending</h4></div></div>
<p>Blending combines a fragment's R, G, B, and A values with those stored in the frame buffer at the corresponding location. The blending, which is performed only in RGBA mode, depends on the alpha value of the fragment and that of the corresponding currently stored pixel; it might also depend on the RGB values. You control blending with <tt>glBlendFunc()</tt>, which allows you to indicate the source and destination blending factors.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5362048"></a>Dithering</h4></div></div>
<p>If dithering is enabled, a dithering algorithm is applied to the fragment's color or color index value. This algorithm depends only on the fragment's value and its <tt>x</tt> and <tt>y</tt> window coordinates. </p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5362070"></a>Logical Operations</h4></div></div>
<p>Finally, a logical operation can be applied between the fragment and the value stored at the corresponding location in the frame buffer; the result replaces the current frame buffer value. You choose the desired logical operation with <tt>glLogicOp()</tt>. Logical operations are performed only on color indices, never on RGBA values. </p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5362092"></a>Pixels</h3></div></div>
<p>During the previous stage of the OpenGL pipeline, fragments are converted to pixels in the frame buffer. The frame buffer is actually organized into a set of logical buffers&#8212;the <i>color, depth, stencil, </i>and<i> accumulation </i>buffers. The color buffer itself consists of a <i>front left, front right, back left, back right</i>, and some number of <i>auxiliary </i>buffers. You can issue commands to control these buffers, and you can directly read or copy pixels from them. (Note that the particular OpenGL context you're using may not provide all of these buffers.)</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5362774"></a>Frame Buffer Operations</h4></div></div>
<p>You can select into which buffer color values are written with <tt>glDrawBuffer()</tt>. In addition, four different commands are used to mask the writing of bits to each of the logical frame buffers after all per-fragment operations have been performed: <tt>glIndexMask()</tt>,<tt> glColorMask()</tt>,<tt> glDepthMask()</tt>, and <tt>glStencilMask()</tt>. The operation of the accumulation buffer is controlled with <tt>glAccum()</tt>. Finally, <tt>glClear()</tt> sets every pixel in a specified subset of the buffers to the value specified with<tt> glClearColor()</tt>, <tt>glClearIndex()</tt>, <tt>glClearDepth()</tt>, <tt>glClearStencil()</tt>, or <tt>glClearAccum()</tt>.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5362850"></a>Reading or Copying Pixels</h4></div></div>
<p>You can read pixels from the frame buffer into memory, encode them in various ways, and store the encoded result in memory with <tt>glReadPixels()</tt>. In addition, you can copy a rectangle of pixel values from one region of the frame buffer to another with <tt>glCopyPixels()</tt>. The command <tt>glReadBuffer()</tt> controls from which color buffer the pixels are read or copied. </p>
</div></div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5362912"></a><a name="id23039"></a>Additional OpenGL Commands</h2></div></div>
<p>This section briefly describes special groups of commands that weren't explicitly shown as part of OpenGL's processing pipeline. These commands accomplish such diverse tasks as evaluating polynomials, using display lists, and obtaining the values of OpenGL state variables.</p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5362948"></a>Using Evaluators</h3></div></div>
<p>OpenGL's evaluator commands allow you to use a polynomial mapping to produce vertices, normals, texture coordinates, and colors. These calculated values are then passed on to the pipeline as if they had been directly specified. The evaluator facility is also the basis for the NURBS (Non-Uniform Rational B-Spline) commands, which allow you to define curves and surfaces, as described later in this chapter under <a href="ch02.html#id24847">&quot;OpenGL Utility Library.&quot;</a>
</p>
<p>The first step involved in using evaluators is to define the appropriate one- or two-dimensional polynomial mapping using <tt>glMap*()</tt>. The domain values for this map can then be specified and evaluated in one of two ways:</p>
<div class="itemizedlist"><ul type="disc"><li><p>By defining a series of evenly spaced domain values to be mapped using <tt>glMapGrid*()</tt> and then evaluating a rectangular subset of that grid with <tt>glEvalMesh*()</tt>. A single point of the grid can be evaluated using <tt>glEvalPoint*()</tt>.</p>
</li>
<li><p>By explicitly specifying a desired domain value as an argument to <tt>glEvalCoord*()</tt>, which evaluates the maps at that value. </p>
</li>
</ul></div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5363026"></a><a name="id13521"></a>Performing Selection and Feedback</h3></div></div>
<p>Selection, feedback, and rendering are mutually exclusive modes of operation. Rendering is the normal, default mode during which fragments are produced by rasterization; in selection and feedback modes, no fragments are produced and therefore no frame buffer modification occurs. In selection mode, you can determine which primitives would be drawn into some region of a window; in feedback mode, information about primitives that would be rasterized is fed back to the application. You select among these three modes with <tt>glRenderMode()</tt>. </p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5363052"></a>Selection</h4></div></div>
<p>Selection works by returning the current contents of the name stack, which is an array of integer-valued names. You assign the names and build the name stack within the modeling code that specifies the geometry of objects you want to draw. Then, in selection mode, whenever a primitive intersects the clip volume, a selection hit occurs. The hit record, which is written into the selection array you've supplied with <tt>glSelectBuffer()</tt>, contains information about the contents of the name stack at the time of the hit. (Note that <tt>glSelectBuffer()</tt> needs to be called before OpenGL is put into selection mode with <tt>glRenderMode()</tt>. Also, the entire contents of the name stack isn't guaranteed to be returned until <tt>glRenderMode()</tt> is called to take OpenGL out of selection mode.)  You manipulate the name stack with <tt>glInitNames()</tt>, <tt>glLoadName()</tt>, <tt>glPushName()</tt>, and <tt>glPopName()</tt>. In addition, you might want to use an OpenGL Utility Library routine for selection, <tt>gluPickMatrix()</tt>, which is described later in this chapter under <a href="ch02.html#id24847">&quot;OpenGL Utility Library.&quot;</a>
</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5363152"></a>Feedback</h4></div></div>
<p>In feedback mode, each primitive that would be rasterized generates a block of values that is copied into the feedback array. You supply this array with <tt>glFeedbackBuffer()</tt>, which must be called before OpenGL is put into feedback mode. Each block of values begins with a code indicating the primitive type, followed by values that describe the primitive's vertices and associated data. Entries are also written for bitmaps and pixel rectangles. Values are not guaranteed to be written into the feedback array until <tt>glRenderMode()</tt> is called to take OpenGL out of feedback mode. You can use <tt>glPassThrough()</tt> to supply a marker that's returned in feedback mode as if it were a primitive. </p>
</div></div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5363189"></a>Using Display Lists</h3></div></div>
<p>A display list is simply a group of OpenGL commands that has been stored for subsequent execution. The <tt>glNewList()</tt> command begins the creation of a display list, and <tt>glEndList()</tt> ends it. With few exceptions, OpenGL commands called between <tt>glNewList()</tt> and <tt>glEndList()</tt> are appended to the display list, and optionally executed as well. (The reference page for <tt>glNewList()</tt> lists the commands that can't be stored and executed from within a display list.) To trigger the execution of a list or set of lists, use <tt>glCallList()</tt> or <tt>glCallLists()</tt> and supply the identifying number of a particular list or lists. You can manage the indices used to identify display lists with <tt>glGenLists()</tt>, <tt>glListBase()</tt>, and <tt>glIsList()</tt>. Finally, you can delete a set of display lists with <tt>glDeleteLists()</tt>. </p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5436017"></a>Managing Modes and Execution</h3></div></div>
<p>The effect of many OpenGL commands depends on whether a particular mode is in effect. You use <tt>glEnable()</tt> and <tt>glDisable()</tt> to set such modes and <tt>glIsEnabled()</tt> to determine whether a particular mode is set.</p>
<p>You can control the execution of previously issued OpenGL commands with <tt>glFinish()</tt>, which forces all such commands to complete, or <tt>glFlush()</tt>, which ensures that all such commands will be completed in a finite time. </p>
<p>A particular implementation of OpenGL may allow certain behaviors to be controlled with hints, by using the <tt>glHint()</tt> command. Possible behaviors are the quality of color and texture coordinate interpolation, the accuracy of fog calculations, and the sampling quality of antialiased points, lines, or polygons.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5436075"></a>Obtaining State Information</h3></div></div>
<p>OpenGL maintains numerous state variables that affect the behavior of many commands. Some of these variables have specialized query commands:</p>
<p>glGetLight()<br>
glGetMaterial()<br>
glGetClipPlane()<br>
glGetPolygonStipple()<br>
glGetTexEnv()<br>
glGetTexGen()<br>
glGetTexImage()<br>
glGetTexLevelParameter()<br>
glGetTexParameter()<br>
glGetMap()<br>
glGetPixelMap()</p>
<p>The value of other state variables can be obtained with <tt>glGetBooleanv()</tt>, <tt>glGetDoublev()</tt>, <tt>glGetFloatv()</tt>, or <tt>glGetIntegerv()</tt>, as appropriate. The reference page for <span class="bold"><b>glGet*()</b></span> explains how to use these commands. Other query commands you might want to use are <tt>glGetError()</tt>, <tt>glGetString()</tt>, and <tt>glIsEnabled()</tt>. (See <a href="ch02.html#id30708">&quot;Handling Errors&quot;</a>
 later in this chapter for more information about routines related to error handling.) Finally, you can save and restore sets of state variables with <tt>glPushAttrib()</tt> and <tt>glPopAttrib()</tt>.</p>
</div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5436272"></a><a name="id24847"></a>OpenGL Utility Library </h2></div></div>
<p>The OpenGL Utility Library (GLU) contains several groups of commands that complement the core OpenGL interface by providing support for auxiliary features. Since these utility routines make use of core OpenGL commands, any OpenGL implementation is guaranteed to support the utility routines. Note that the prefix for Utility Library routines is <i>glu</i> rather than <i>gl</i>. </p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5436298"></a>Manipulating Images for Use in Texturing</h3></div></div>
<p>GLU provides image scaling and automatic mipmapping routines to simplify the specification of texture images. The routine <tt>gluScaleImage()</tt> scales a specified image to an accepted texture size; the resulting image can then be passed to OpenGL as a texture. The automatic mipmapping routines <tt>gluBuild1DMipmaps()</tt> and <tt>gluBuild2DMipmaps()</tt> create mipmapped texture images from a specified image and pass them to <tt>glTexImage1D()</tt> and <tt>glTexImage2D()</tt>, respectively.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5436338"></a>Transforming Coordinates</h3></div></div>
<p>Several commonly used matrix transformation routines are provided. You can set up a two-dimensional orthographic viewing region with <tt>gluOrtho2D()</tt>, a perspective viewing volume using <tt>gluPerspective()</tt>, or a viewing volume that's centered on a specified eyepoint with <tt>gluLookAt()</tt>. Each of these routines creates the desired matrix and applies it to the current matrix using <tt>glMultMatrix()</tt>. </p>
<p>The <tt>gluPickMatrix()</tt> routine simplifies selection by creating a matrix that restricts drawing to a small region of the viewport. If you rerender the scene in selection mode after this matrix has been applied, all objects that would be drawn near the cursor will be selected and information about them stored in the selection buffer. See <a href="ch02.html#id13521">&quot;Performing Selection and Feedback&quot;</a>
 earlier in this chapter for more information about selection mode.</p>
<p>If you need to determine where in the window an object is being drawn, use <tt>gluProject()</tt>, which converts specified coordinates from object coordinates to window coordinates; <tt>gluUnProject()</tt> performs the inverse conversion.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5436464"></a>Polygon Tessellation</h3></div></div>
<p>The polygon tessellation routines triangulate a concave polygon with one or more contours. To use this GLU feature, first create a tessellation object with <tt>gluNewTess()</tt>, and define callback routines that will be used to process the triangles generated by the tessellator (with <tt>gluTessCallBack()</tt>). Then use <tt>gluBeginPolygon()</tt>, <tt>gluTessVertex()</tt>, <tt>gluNextContour()</tt>, and <tt>gluEndPolygon()</tt> to specify the concave polygon to be tessellated. Unneeded tessellation objects can be destroyed with <tt>gluDeleteTess()</tt>.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5436515"></a>Rendering Spheres, Cylinders, and Disks</h3></div></div>
<p>You can render spheres, cylinders, and disks using the GLU quadric routines. To do this, create a quadric object with <tt>gluNewQuadric()</tt>. (To destroy this object when you're finished with it, use <tt>gluDeleteQuadric()</tt>.) Then specify the desired rendering style, as listed below, with the appropriate routine (unless you're satisfied with the default values):</p>
<div class="itemizedlist"><ul type="disc"><li><p>Whether surface normals should be generated, and if so, whether there should be one normal per vertex or one normal per face: <tt>gluQuadricNormals()</tt></p>
</li>
<li><p>Whether texture coodinates should be generated: <tt>gluQuadricTexture()</tt></p>
</li>
<li><p>Which side of the quadric should be considered the outside and which the inside: <tt>gluQuadricOrientation()</tt></p>
</li>
<li><p>Whether the quadric should be drawn as a set of polygons, lines, or points: <tt>gluQuadricDrawStyle()</tt></p>
</li>
</ul></div><p>After you've specified the rendering style, simply invoke the rendering routine for the desired type of quadric object<tt>: gluSphere()</tt>, <tt>gluCylinder()</tt>, <tt>gluDisk()</tt>, or <tt>gluPartialDisk()</tt>. If an error occurs during rendering, the error-handling routine you've specified with <tt>gluQuadricCallBack()</tt> is invoked.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5436622"></a>NURBS Curves and Surfaces</h3></div></div>
<p>NURBS (Non-Uniform Rational B-Spline) curves and surfaces are converted to OpenGL evaluators by the routines described in this section. You can create and delete a NURBS object with <tt>gluNewNurbsRenderer()</tt> and <tt>gluDeleteNurbsRenderer()</tt>, and establish an error-handling routine with <tt>gluNurbsCallback()</tt>. </p>
<p>You specify the desired curves and surfaces with different sets of routines&#8212;<tt>gluBeginCurve()</tt>, <tt>gluNurbsCurve()</tt>, and <tt>gluEndCurve()</tt> for curves or <tt>gluBeginSurface()</tt>, <tt>gluNurbsSurface()</tt>, and <tt>gluEndSurface()</tt> for surfaces. You can also specify a trimming region, which defines a subset of the NURBS surface domain to be evaluated, thereby allowing you to create surfaces that have smooth boundaries or that contain holes. The trimming routines are <tt>gluBeginTrim()</tt>, <tt>gluPwlCurve()</tt>, <tt>gluNurbsCurve()</tt>, and <tt>gluEndTrim()</tt>. </p>
<p>As with quadric objects, you can control how NURBS curves and surfaces are rendered:</p>
<div class="itemizedlist"><ul type="disc"><li><p>Whether a curve or surface should be discarded if its control polyhedron lies outside the current viewport</p>
</li>
<li><p>What the maximum length should be (in pixels) of edges of polygons used to render curves and surfaces</p>
</li>
<li><p>Whether the projection matrix, modelview matrix, and viewport should be taken from the OpenGL server or whether you'll supply them explictly with <tt>gluLoadSamplingMatrices()</tt></p>
</li>
</ul></div><p>Use <tt>gluNurbsProperty()</tt> to set these properties, or use the default values. You can query a NURBS object about its rendering style with <tt>gluGetNurbsProperty()</tt>.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5436813"></a><a name="id30708"></a>Handling Errors</h3></div></div>
<p>The routine <tt>gluErrorString()</tt> is provided for retrieving an error string that corresponds to an OpenGL or GLU error code. The currently defined OpenGL error codes are described in the <tt>glGetError()</tt> reference page. The GLU error codes are listed in the <tt>gluErrorString()</tt>, <tt>gluTessCallback()</tt>, <tt>gluQuadricCallback()</tt>, and <tt>gluNurbsCallback()</tt> reference pages. Errors generated by GLX routines are listed in the relevant reference pages for those routines. </p>
</div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5436863"></a><a name="id86751"></a>OpenGL Extension to the X Window System</h2></div></div>
<p>In the X Window System, OpenGL rendering is made available as an extension to X in the formal X sense: connection and authentication are accomplished with the normal X mechanisms. As with other X extensions, there is a defined network protocol for OpenGL's rendering commands encapsulated within the X byte stream. Since performance is critical in three-dimensional rendering, the OpenGL extension to X allows OpenGL to bypass the X server's involvement in data encoding, copying, and interpretation and instead render directly to the graphics pipeline. </p>
<p>This section briefly discusses the routines defined as part of GLX; these routines have the prefix <i>glX</i>. You'll need to have some knowledge of X in order to fully understand the following and to use GLX successfully.</p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5436917"></a>Initialization</h3></div></div>
<p>Use <tt>glXQueryExtension()</tt> and <tt>glXQueryVersion()</tt> to determine whether the GLX extension is defined for an X server, and if so, which version is bound in the server. The <tt>glXChooseVisual()</tt> routine returns a pointer to an XVisualInfo structure describing the visual that best meets the client's specified attributes. You can query a visual about its support of a particular OpenGL attribute with <tt>glXGetConfig()</tt>.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5436981"></a>Controlling Rendering</h3></div></div>
<p>Several GLX routines are provided for creating and managing an OpenGL rendering context. You can use such a context to render off-screen if you want. Routines are also provided for such tasks as synchronizing execution between the X and OpenGL streams, swapping front and back buffers, and using an X font.</p>
<div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5436995"></a>Managing an OpenGL Rendering Context</h4></div></div>
<p>An OpenGL rendering context is created with <tt>glXCreateContext()</tt>. One of the arguments to this routine allows you to request a direct rendering context that bypasses the X server as described above. (Note that in order to do direct rendering, the X server connection must be local and the OpenGL implementation needs to support direct rendering.) You can determine whether a GLX context is direct with <tt>glXIsDirect()</tt>.</p>
<p>To make a rendering context current, use <tt>glXMakeCurrent()</tt>; <tt>glXGetCurrentContext()</tt> returns the current context. (You can also obtain the current drawable with <tt>glXGetCurrentDrawable()</tt>.) Remember that only one context can be current for any thread at any one time. If you have multiple contexts, you can copy selected groups of OpenGL state variables from one context to another with <tt>glXCopyContext()</tt>. When you're finished with a particular context, destroy it with <tt>glXDestroyContext()</tt>. </p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5437056"></a>Off-Screen Rendering</h4></div></div>
<p>To render off-screen, first create an X Pixmap and then pass this as an argument to <tt>glXCreateGLXPixmap()</tt>. Once rendering is completed, you can destroy the association between the X and GLX Pixmaps with <tt>glXDestroyGLXPixmap()</tt>. (Off-screen rendering isn't guaranteed to be supported for direct renderers.) </p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5437080"></a>Synchronizing Execution</h4></div></div>
<p>To prevent X requests from executing until any outstanding OpenGL rendering is completed, call <tt>glXWaitGL()</tt>. Then, any previously issued OpenGL commands are guaranteed to be executed before any X rendering calls made after <tt>glXWaitGL()</tt>. Although the same result can be achieved with <tt>glFinish()</tt>, <tt>glXWaitGL()</tt> doesn't require a round trip to the server and thus is more efficient in cases where the client and server are on separate machines. </p>
<p>To prevent an OpenGL command sequence from executing until any outstanding X requests are completed, use <tt>glXWaitX()</tt>. This routine guarantees that previously issued X rendering calls will be executed before any OpenGL calls made after <tt>glXWaitX()</tt>.</p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5437155"></a>Swapping Buffers</h4></div></div>
<p>For drawables that are double-buffered, the front and back buffers can be exchanged by calling <tt>glXSwapBuffers()</tt>. An implicit <tt>glFlush()</tt> is done as part of this routine. </p>
</div><div class="section"><div class="titlepage"><div><h4 class="title"><a name="id5437176"></a>Using an X Font</h4></div></div>
<p>A shortcut for using X fonts in OpenGL is provided with the command <tt>glXUseXFont()</tt>. </p>
</div></div></div></div><!--CONTENT_END--><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch01.html">Prev</a> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Table of Contents</a></td><td width="40%" align="right"> <a accesskey="n" href="ch03.html">Next</a></td></tr><tr><td width="40%" align="left">Chapter 1. Introduction to OpenGL </td><td width="20%" align="center"> </td><td width="40%" align="right">Chapter 3. Summary of Commands and Routines </td></tr></table></div></body></html>
