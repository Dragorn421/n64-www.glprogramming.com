<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type"><title>Chapter 1. Introduction to OpenGL</title><meta name="generator" content="DocBook XSL Stylesheets V1.49"><meta name="generator" content="SGI XSL DocBook Customization Stylesheets V1.0"><link rel="home" href="index.html" title="OpenGL Reference Manual (Addison-Wesley Publishing Company)"><link rel="up" href="bk02.html" title="OpenGL Reference Manual"><link rel="previous" href="pr01.html" title="Preface"><link rel="next" href="ch02.html" title="Chapter 2. Overview of Commands and Routines"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter 1. Introduction to OpenGL</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="pr01.html">Prev</a> </td><th width="60%" align="center">OpenGL Reference Manual</th><td width="20%" align="right"> <a accesskey="n" href="ch02.html">Next</a></td></tr></table><hr></div><!--CONTENT_BEGIN--><div class="chapter"><div class="titlepage"><div><h2 class="title"><a name="id5365393"></a>Chapter 1. <a name="id60402"></a>Introduction to OpenGL</h2></div></div>
<p>As a software interface for graphics hardware, OpenGL's main purpose is to render two- and three-dimensional objects into a frame buffer. These objects are described as sequences of vertices (which define geometric objects) or pixels (which define images). OpenGL performs several processing steps on this data to convert it to pixels to form the final desired image in the frame buffer. </p>
<p>This chapter presents a global view of how OpenGL works; it contains the following major sections:</p>
<div class="itemizedlist"><ul type="disc"><li><p><a href="ch01.html#id32221">&quot;OpenGL Fundamentals&quot;</a>
 briefly explains basic OpenGL concepts, such as what a graphic primitive is and how OpenGL implements a client-server execution model.</p>
</li>
<li><p><a href="ch01.html#id27075">&quot;Basic OpenGL Operation&quot;</a>
 gives a high-level description of how OpenGL processes data and produces a corresponding image in the frame buffer.</p>
</li>
</ul></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5419136"></a><a name="id32221"></a>OpenGL Fundamentals</h2></div></div>
<p>This section explains some of the concepts inherent in OpenGL.</p>
<div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5419148"></a>Primitives and Commands</h3></div></div>
<p>OpenGL draws <i>primitives</i>&#8212;points, line segments, or polygons&#8212;subject to several selectable modes. You can control modes independently of each other; that is, setting one mode doesn't affect whether other modes are set (although many modes may interact to determine what eventually ends up in the frame buffer). Primitives are specified, modes are set, and other OpenGL operations are described by issuing commands in the form of function calls.</p>
<p>Primitives are defined by a group of one or more <i>vertices</i>. A vertex defines a point, an endpoint of a line, or a corner of a polygon where two edges meet. Data (consisting of vertex coordinates, colors, normals, texture coordinates, and edge flags) is associated with a vertex, and each vertex and its associated data are processed independently, in order, and in the same way. The only exception to this rule is if the group of vertices must be <i>clipped</i> so that a particular primitive fits within a specified region; in this case, vertex data may be modified and new vertices created. The type of clipping depends on which primitive the group of vertices represents.</p>
<p>Commands are always processed in the order in which they are received, although there may be an indeterminate delay before a command takes effect. This means that each primitive is drawn completely before any subsequent command takes effect. It also means that state-querying commands return data that's consistent with complete execution of all previously issued OpenGL commands.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5419221"></a>Procedural versus Descriptive</h3></div></div>
<p>OpenGL provides you with fairly direct control over the fundamental operations of two- and three-dimensional graphics. This includes specification of such parameters as transformation matrices, lighting equation coefficients, antialiasing methods, and pixel update operators. However, it doesn't provide you with a means for describing or modeling complex geometric objects. Thus, the OpenGL commands you issue specify how a certain result should be produced (what procedure should be followed) rather than what exactly that result should look like. That is, OpenGL is fundamentally procedural rather than descriptive. Because of this procedural nature, it helps to know how OpenGL works&#8212;the order in which it carries out its operations, for example&#8212;in order to fully understand how to use it.</p>
</div><div class="section"><div class="titlepage"><div><h3 class="title"><a name="id5419256"></a>Execution Model</h3></div></div>
<p>The model for interpretation of OpenGL commands is client-server. An application (the client) issues commands, which are interpreted and processed by OpenGL (the server). The server may or may not operate on the same computer as the client. In this sense, OpenGL is network-transparent. A server can maintain several GL <i>contexts</i>, each of which is an encapsulated GL state. A client can connect to any one of these contexts. The required network protocol can be implemented by augmenting an already existing protocol (such as that of the X Window System) or by using an independent protocol. No OpenGL commands are provided for obtaining user input. </p>
<p>The effects of OpenGL commands on the frame buffer are ultimately controlled by the window system that allocates frame buffer resources. The window system determines which portions of the frame buffer OpenGL may access at any given time and communicates to OpenGL how those portions are structured. Therefore, there are no OpenGL commands to configure the frame buffer or initialize OpenGL. Frame buffer configuration is done outside of OpenGL in conjunction with the window system; OpenGL initialization takes place when the window system allocates a window for OpenGL rendering. (GLX, the X extension of the OpenGL interface, provides these capabilities, as described in <a href="ch02.html#id86751">&quot;OpenGL Extension to the X Window System.&quot;</a>
)</p>
</div></div><div class="section"><div class="titlepage"><div><h2 class="title"><a name="id5419328"></a><a name="id27075"></a>Basic OpenGL Operation</h2></div></div>
<p>The figure shown below gives an abstract, high-level block diagram of how OpenGL processes data.  In the diagram, commands enter from the left and proceed through what can be thought of as a processing pipeline. Some commands specify geometric objects to be drawn, and others control how the objects are handled during the various processing stages. </p>
<p><div class="figure"><p><a name="id5419346"></a><b>Figure 1-1. 
OpenGL Block Diagram</b></p>
<div class="mediaobject"><img src="figures/OpenGLOper.gif" height="241" width="488"></div></div><br>
</p>
<p>As shown by the first block in the diagram, rather than having all commands proceed immediately through the pipeline, you can choose to accumulate some of them in a <i>display list</i> for processing at a later time. </p>
<p>The <i>evaluator</i> stage of processing provides an efficient means for approximating curve and surface geometry by evaluating polynomial commands of input values. During the next stage, <i>per-vertex operations and primitive assembly</i>, OpenGL processes geometric primitives&#8212;points, line segments, and polygons, all of which are described by vertices. Vertices are transformed and lit, and primitives are clipped to the viewport in preparation for the next stage.</p>
<p><i>Rasterization</i> produces a series of frame buffer addresses and associated values using a two-dimensional description of a point, line segment, or polygon. Each <i>fragment</i> so produced is fed into the last stage, <i>per-fragment operations</i>, which performs the final operations on the data before it's stored as pixels in the <i>frame buffer</i>. These operations include conditional updates to the frame buffer based on incoming and previously stored z-values (for z-buffering) and blending of incoming pixel colors with stored colors, as well as masking and other logical operations on pixel values.</p>
<p>Input data can be in the form of pixels rather than vertices. Such data, which might describe an image for use in texture mapping, skips the first stage of processing described above and instead is processed as pixels, in the <i>pixel operations</i> stage. The result of this stage is either stored as <i>texture memory</i>, for use in the rasterization stage, or rasterized and the resulting fragments merged into the frame buffer just as if they were generated from geometric data.</p>
<p>All elements of OpenGL state, including the contents of the texture memory and even of the frame buffer, can be obtained by an OpenGL application.<a name="id30564"></a></p>
</div></div><!--CONTENT_END--><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="pr01.html">Prev</a> </td><td width="20%" align="center"><a accesskey="h" href="index.html">Table of Contents</a></td><td width="40%" align="right"> <a accesskey="n" href="ch02.html">Next</a></td></tr><tr><td width="40%" align="left">Preface </td><td width="20%" align="center"> </td><td width="40%" align="right">Chapter 2. Overview of Commands and Routines </td></tr></table></div></body></html>
