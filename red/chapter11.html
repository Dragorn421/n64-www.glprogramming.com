<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html">
<TITLE>Chapter 11 - OpenGL Programming Guide </TITLE>

</HEAD>

<body bgcolor="#ffffff">

<div align="left">
<table border="0" cellpadding="1" cellspacing="0" width="95%" bgcolor="#226666">
<tr><td>
<table border="0" cellpadding="15" cellspacing="0" width="100%" bgcolor="#F2FFF6">
<tr align=center><td>
<font size="4" color="#226666"><b>OpenGL Programming Guide</b></font>
</td></tr>
</table>
</td></tr>
<tr align="right" bgcolor="#ffffff"><td>
 
<a href="./index.html" onMouseOver="status='OpenGL Programming Guide Index';return true" onMouseOut="status=''">
<font color="#000000">Programming Guide</font></a> &gt; 
Chapter 11
</td></tr>
</table>
</div>
<br><br>

<div align="left">
<table border="0" cellpadding="0" cellspacing="0" width="95%">
<tr><td>

<H2>Chapter 11<BR>
Tessellators and Quadrics</H2>

<hr size="1" noshade style="color:#226666;">

<B><P>Chapter Objectives</B> </P>
<P>After reading this chapter, you'll be able to do the following: </P>

<UL>
<LI>Render concave filled polygons by first tessellating them into convex polygons, which can be rendered using standard OpenGL routines.<BR>
</LI>
<LI>Use the GLU library to create quadrics objects to render and model the surfaces of spheres and cylinders and to tessellate disks (circles) and partial disks (arcs).</LI></UL>

<P>The OpenGL library (GL) is designed for low-level operations, both streamlined and accessible to hardware acceleration. The OpenGL Utility Library (GLU) complements the OpenGL library, supporting higher-level operations. Some of the GLU operations are covered in other chapters. Mipmapping (<B>gluBuild*DMipmaps()</B>) and image scaling (<B>gluScaleImage()</B>) are discussed along with other facets of texture mapping in <A HREF="chapter09.html">Chapter 9</A>. Several matrix transformation GLU routines (<B>gluOrtho2D()</B>, <B>gluPerspective()</B>, <B>gluLookAt()</B>, <B>gluProject()</B>, and <B>gluUnProject()</B>) are described in <A HREF="chapter03.html">Chapter 3</A>. The use of <B>gluPickMatrix()</B> is explained in <A HREF="chapter13.html">Chapter 13</A>. The GLU NURBS facilities, which are built atop OpenGL evaluators, are covered in <A HREF="chapter12.html">Chapter 12</A>. Only two GLU topics remain: polygon tessellators and quadric surfaces, and those topics are discussed in this chapter. </P>
<P>To optimize performance, the basic OpenGL only renders convex polygons, but the GLU contains routines to tessellate concave polygons into convex ones, which the basic OpenGL can handle. Where the basic OpenGL operates upon simple primitives, such as points, lines, and filled polygons, the GLU can create higher-level objects, such as the surfaces of spheres, cylinders, and cones. </P>
<P>This chapter has the following major sections. </P>

<UL>
<LI><A HREF="#name1">"Polygon Tessellation"</A> explains how to tessellate convex polygons into easier-to-render convex polygons.<BR>
</LI>
<LI><A HREF="#name2">"Quadrics: Rendering Spheres, Cylinders, and Disks"</A> describes how to generate spheres, cylinders, circles and arcs, including data such as surface normals and texture coordinates.</LI></UL>

<br>
<a name = name1>
<H2>Polygon Tessellation</H2>
<P>As discussed in <A HREF="chapter02.html#name2">"Describing Points, Lines, and Polygons" in Chapter 2</A>, OpenGL can directly display only simple convex polygons. A polygon is simple if the edges intersect only at vertices, there are no duplicate vertices, and exactly two edges meet at any vertex. If your application requires the display of concave polygons, polygons containing holes, or polygons with intersecting edges, those polygons must first be subdivided into simple convex polygons before they can be displayed. Such subdivision is called tessellation, and the GLU provides a collection of routines that perform tessellation. These routines take as input arbitrary contours, which describe hard-to-render polygons, and they return some combination of triangles, triangle meshes, triangle fans, or lines. </P>
<P>Figure 11-1 shows some contours of polygons that require tessellation: from left to right, a concave polygon, a polygon with a hole, and a self-intersecting polygon. </P>
<P><IMG SRC="images/Image126.gif"></P>
<B><P>Figure 11-1 : </B>Contours That Require Tessellation </P>

<P>If you think a polygon may need tessellation, follow these typical steps. </P><DIR>
<DIR>

<P>Create a new tessellation object with <B>gluNewTess()</B>.<BR>
</P>
<P>Use <B>gluTessCallback()</B> several times to register callback functions to perform operations during the tessellation. The trickiest case for a callback function is when the tessellation algorithm detects an intersection and must call the function registered for the GLU_TESS_COMBINE callback.<BR>
</P>
<P>Specify tessellation properties by calling <B>gluTessProperty()</B>. The most important property is the winding rule, which determines the regions that should be filled and those that should remain unshaded.<BR>
</P>
<P>Create and render tessellated polygons by specifying the contours of one or more closed polygons. If the data for the object is static, encapsulate the tessellated polygons in a display list. (If you don't have to recalculate the tessellation over and over again, using display lists is more efficient.)<BR>
</P>
<P>If you need to tessellate something else, you may reuse your tessellation object. If you are forever finished with your tessellation object, you may delete it with <B>gluDeleteTess()</B>.</P></DIR>
</DIR>

<B><P>Note: </B>The tessellator described here was introduced in version 1.2 of the GLU. If you are using an older version of the GLU, you must use routines described in <A HREF="#name3">"Describing GLU Errors"</A>. To query which version of GLU you have, use <B>gluGetString(GLU_VERSION)</B>, which returns a string with your GLU version number. If you don't seem to have <B>gluGetString()</B> in your GLU, then you have GLU 1.0, which did not yet have the <B>gluGetString()</B> routine. </P>
<H3>Create a Tessellation Object</H3>
<P>As a complex polygon is being described and tessellated, it has associated data, such as the vertices, edges, and callback functions. All this data is tied to a single tessellation object. To perform tessellation, your program first has to create a tessellation object using the routine <B>gluNewTess()</B>. </P>
<I><DL>
<DT>GLUtesselator*<B> gluNewTess</B>(void);</I> </DT>
<I><DD>Creates a new tessellation object and returns a pointer to it. A null pointer is returned if the creation fails. </DD>
</DL>
</I><P>A single tessellation object can be reused for all your tessellations. This object is required only because library routines might need to do their own tessellations, and they should be able to do so without interfering with any tessellation that your program is doing. It might also be useful to have multiple tessellation objects if you want to use different sets of callbacks for different tessellations. A typical program, however, allocates a single tessellation object and uses it for all its tessellations. There's no real need to free it because it uses a small amount of memory. On the other hand, it never hurts to be tidy. </P>
<H3>Tessellation Callback Routines</H3>
<P>After you create a tessellation object, you must provide a series of callback routines to be called at appropriate times during the tessellation. After specifying the callbacks, you describe the contours of one or more polygons using GLU routines. When the description of the contours is complete, the tessellation facility invokes your callback routines as necessary. </P>
<P>Any functions that are omitted are simply not called during the tessellation, and any information they might have returned to your program is lost. All are specified by the single routine <B>gluTessCallback()</B>. </P>
<I><DL>
<DT>void <B>gluTessCallback</B>(GLUtesselator *</I><VAR>tessobj</VAR><I>, GLenum </I><VAR>type</VAR><I>, void (*</I><VAR>fn</VAR><I>)()); </DT>
<DD>Associates the callback function </I><VAR>fn</VAR><I> with the tessellation object </I><VAR>tessobj</VAR><I>. The type of the callback is determined by the parameter </I><VAR>type</VAR><I>, which can be GLU_TESS_BEGIN, GLU_TESS_BEGIN_DATA, GLU_TESS_EDGE_FLAG, GLU_TESS_EDGE_FLAG_DATA, GLU_TESS_VERTEX, GLU_TESS_VERTEX_DATA, GLU_TESS_END, GLU_TESS_END_DATA, GLU_TESS_COMBINE, GLU_TESS_COMBINE_DATA, GLU_TESS_ERROR, and GLU_TESS_ERROR_DATA. The twelve possible callback functions have the following prototypes:</I> </DD>
<I><DD>GLU_TESS_BEGIN void <B>begin</B>(GLenum </I><VAR>type</VAR><I>);</I> </DD>
<I><DD>GLU_TESS_BEGIN_DATA void <B>begin</B>(GLenum </I><VAR>type</VAR><I>, <BR>
void *</I><VAR>user_data</VAR><I>);</I> </DD>
<I><DD>GLU_TESS_EDGE_FLAG void <B>edgeFlag</B>(GLboolean </I><VAR>flag</VAR><I>);</I> </DD>
<I><DD>GLU_TESS_EDGE_FLAG_DATA void <B>edgeFlag</B>(GLboolean </I><VAR>flag</VAR><I>, <BR>
void *</I><VAR>user_data</VAR><I>);</I> </DD>
<I><DD>GLU_TESS_VERTEX void <B>vertex</B>(void *</I><VAR>vertex_data</VAR><I>);</I> </DD>
<I><DD>GLU_TESS_VERTEX_DATA void <B>vertex</B>(void *</I><VAR>vertex_data</VAR><I>, <BR>
void *</I><VAR>user_data</VAR><I>);</I> </DD>
<I><DD>GLU_TESS_END void <B>end</B>(void);</I> </DD>
<I><DD>GLU_TESS_END_DATA void <B>end</B>(void *</I><VAR>user_data</VAR><I>);</I> </DD>
<I><DD>GLU_TESS_ERROR void <B>error</B>(GLenum </I><VAR>errno</VAR><I>);</I> </DD>
<I><DD>GLU_TESS_ERROR_DATA void <B>error</B>(GLenum </I><VAR>errno</VAR><I>, void *</I><VAR>user_data</VAR><I>);</I> </DD>
<I><DD>GLU_TESS_COMBINE void <B>combine</B>(GLdouble </I><VAR>coords</VAR><I>[3],<BR>
void </I><VAR>*vertex_data</VAR><I>[4], <BR>
GLfloat </I><VAR>weight</VAR><I>[4], <BR>
void </I><VAR>**outData</VAR><I>);</I> </DD>
<I><DD>GLU_TESS_COMBINE_DATA void <B>combine</B>(GLdouble </I><VAR>coords</VAR><I>[3],<BR>
void </I><VAR>*vertex_data</VAR><I>[4], <BR>
GLfloat </I><VAR>weight</VAR><I>[4], <BR>
void </I><VAR>**outData</VAR><I>, <BR>
void *</I><VAR>user_data</VAR><I>);</DD>
</DL>
</I><P>To change a callback routine, simply call <B>gluTessCallback()</B> with the new routine. To eliminate a callback routine without replacing it with a new one, pass <B>gluTessCallback()</B> a null pointer for the appropriate function. </P>
<P>As tessellation proceeds, the callback routines are called in a manner <BR>
similar to how you use the OpenGL commands <B>glBegin()</B>, <B>glEdgeFlag*()</B>, <B>glVertex*()</B>, and <B>glEnd()</B>. (See <A HREF="chapter02.html#name11">"Marking Polygon Boundary Edges" in Chapter 2</A> for more information about <B>glEdgeFlag*()</B>.) The combine callback is used to create new vertices where edges intersect. The error callback is invoked during the tessellation only if something goes wrong. </P>
<P>For every tessellator object created, a GLU_TESS_BEGIN callback is invoked with one of four possible parameters: GL_TRIANGLE_FAN, GL_TRIANGLE_STRIP, GL_TRIANGLES, and GL_LINE_LOOP. When the tessellator decomposes the polygons, the tessellation algorithm will decide which type of triangle primitive is most efficient to use. (If the GLU_TESS_BOUNDARY_ONLY property is enabled, then GL_LINE_LOOP is used for rendering.) </P>
<P>Since edge flags make no sense in a triangle fan or triangle strip, if there is a callback associated with GLU_TESS_EDGE_FLAG that enables edge flags, the GLU_TESS_BEGIN callback is called only with GL_TRIANGLES. The GLU_TESS_EDGE_FLAG callback works exactly analogously to the OpenGL <B>glEdgeFlag*()</B> call. </P>
<P>After the GLU_TESS_BEGIN callback routine is called and before the callback associated with GLU_TESS_END is called, some combination of the GLU_TESS_EDGE_FLAG and GLU_TESS_VERTEX callbacks is invoked (usually by calls to <B>gluTessVertex()</B>, which is described on page 425). The associated edge flags and vertices are interpreted exactly as they are in OpenGL between <B>glBegin()</B> and the matching <B>glEnd()</B>. </P>
<P>If something goes wrong, the error callback is passed a GLU error number. A character string describing the error is obtained using the routine <B>gluErrorString()</B>. (See <A HREF="#name3">"Describing GLU Errors"</A> for more information about this routine.) </P>
<P>Example 11-1 shows a portion of tess.c, where a tessellation object is created and several callbacks are registered.</P>
<P> </P>
<B><P>Example 11-1 : </B>Registering Tessellation Callbacks: tess.c</P>
<PRE>/*  a portion of init() */
tobj = gluNewTess();
gluTessCallback(tobj, GLU_TESS_VERTEX,
                   (GLvoid (*) ()) &amp;glVertex3dv);
gluTessCallback(tobj, GLU_TESS_BEGIN,
                   (GLvoid (*) ()) &amp;beginCallback);
gluTessCallback(tobj, GLU_TESS_END,
                   (GLvoid (*) ()) &amp;endCallback);
gluTessCallback(tobj, GLU_TESS_ERROR,
                   (GLvoid (*) ()) &amp;errorCallback);

/*  the callback routines registered by gluTessCallback() */

void beginCallback(GLenum which)
{
   glBegin(which);
}

void endCallback(void)
{
   glEnd();
}

void errorCallback(GLenum errorCode)
{
   const GLubyte *estring;

   estring = gluErrorString(errorCode);
   fprintf (stderr, "Tessellation Error: %s\n", estring);
   exit (0);
}
</PRE>
<P>In Example 11-1, the registered GLU_TESS_VERTEX callback is simply <B>glVertex3dv()</B>, and only the coordinates at each vertex are passed along. However, if you want to specify more information at every vertex, such as a color value, a surface normal vector, or texture coordinate, you'll have to make a more complex callback routine. Example 11-2 shows the start of another tessellated object, further along in program tess.c. The registered function <B>vertexCallback()</B> expects to receive a parameter that is a pointer to six double-length floating point values: the <I>x</I>, <I>y</I>, and <I>z</I> coordinates and the red, green, and blue color values, respectively, for that vertex. </P>

<B><P>Example 11-2 : </B>Vertex and Combine Callbacks: tess.c</P>
<PRE>/*  a different portion of init() */
   gluTessCallback(tobj, GLU_TESS_VERTEX,
                   (GLvoid (*) ()) &amp;vertexCallback);
   gluTessCallback(tobj, GLU_TESS_BEGIN,
                   (GLvoid (*) ()) &amp;beginCallback);
   gluTessCallback(tobj, GLU_TESS_END,
                   (GLvoid (*) ()) &amp;endCallback);
   gluTessCallback(tobj, GLU_TESS_ERROR,
                   (GLvoid (*) ()) &amp;errorCallback);
   gluTessCallback(tobj, GLU_TESS_COMBINE,
                   (GLvoid (*) ()) &amp;combineCallback);

/*  new callback routines registered by these calls */
void vertexCallback(GLvoid *vertex)
{
   const GLdouble *pointer;

   pointer = (GLdouble *) vertex;
   glColor3dv(pointer+3);
   glVertex3dv(vertex);
}

void combineCallback(GLdouble coords[3], 
                     GLdouble *vertex_data[4],
                     GLfloat weight[4], GLdouble **dataOut )
{
   GLdouble *vertex;
   int i;

   vertex = (GLdouble *) malloc(6 * sizeof(GLdouble));
   vertex[0] = coords[0];
   vertex[1] = coords[1];
   vertex[2] = coords[2];
   for (i = 3; i &lt; 7; i++)
      vertex[i] = weight[0] * vertex_data[0][i] 
                  + weight[1] * vertex_data[1][i]
                  + weight[2] * vertex_data[2][i] 
                  + weight[3] * vertex_data[3][i];
   *dataOut = vertex;
}
</PRE>
<P>Example 11-2 also shows the use of the GLU_TESS_COMBINE callback. Whenever the tessellation algorithm examines the input contours, detects an intersection, and decides it must create a new vertex, the GLU_TESS_COMBINE callback is invoked. The callback is also called when the tessellator decides to merge features of two vertices that are very close to one another. The newly created vertex is a linear combination of up to four existing vertices, referenced by <VAR>vertex_data</VAR>[0..3] in Example 11-2. The coefficients of the linear combination are given by <VAR>weight</VAR>[0..3]; these weights sum to 1.0. <VAR>coords</VAR> gives the location of the new vertex. </P>
<P>The registered callback routine must allocate memory for another vertex, perform a weighted interpolation of data using <VAR>vertex_data</VAR> and <VAR>weight</VAR>, and return the new vertex pointer as <VAR>dataOut</VAR>. <B>combineCallback()</B> in Example 11-2 interpolates the RGB color value. The function allocates a six-element array, puts the <I>x</I>, <I>y</I>, and <I>z</I> coordinates in the first three elements, and then puts the weighted average of the RGB color values in the last three elements. </P>
<H4>User-Specified Data</H4>
<P>Six kinds of callbacks can be registered. Since there are two versions of each kind of callback, there are twelve callbacks in all. For each kind of callback, there is one with user-specified data and one without. The user-specified data is given by the application to <B>gluTessBeginPolygon()</B> and is then passed, unaltered, to each *DATA callback routine. With GLU_TESS_BEGIN_DATA, the user-specified data may be used for "per-polygon" data. If you specify both versions of a particular callback, the callback with <VAR>user_data</VAR> is used, and the other is ignored. So, although there are twelve callbacks, you can have a maximum of six callback functions active at any time. </P>
<P>For instance, Example 11-2 uses smooth shading, so <B>vertexCallback()</B> specifies an RGB color for every vertex. If you want to do lighting and smooth shading, the callback would specify a surface normal for every vertex. However, if you want lighting and flat shading, you might specify only one surface normal for every polygon, not for every vertex. In that case, you might choose to use the GLU_TESS_BEGIN_DATA callback and pass the vertex coordinates and surface normal in the <VAR>user_data</VAR> pointer. </P>
<H3>Tessellation Properties</H3>
<P>Prior to tessellation and rendering, you may use <B>gluTessProperty()</B> to set several properties to affect the tessellation algorithm. The most important and complicated of these properties is the winding rule, which determines what is considered "interior" and "exterior." </P>
<I><DL>
<DT>void <B>gluTessProperty</B>(GLUtesselator *</I><VAR>tessobj</VAR><I>, GLenum </I><VAR>property</VAR><I>, <BR>
GLdouble </I><VAR>value</VAR><I>);</I> </DT>
<I><DD>For the tessellation object </I><VAR>tessobj</VAR><I>, the current value of </I><VAR>property</VAR><I> is set to </I><VAR>value</VAR><I>. </I><VAR>property</VAR><I> is one of GLU_TESS_BOUNDARY_ONLY, GLU_TESS_TOLERANCE, or GLU_TESS_WINDING_RULE.</I> </DD>
<I><DD>If </I><VAR>property</VAR><I> is GLU_TESS_BOUNDARY_ONLY, </I><VAR>value</VAR><I> is either GL_TRUE or GL_FALSE. When set to GL_TRUE, polygons are no longer tessellated into filled polygons; line loops are drawn to outline the contours that separate the polygon interior and exterior. The default value is GL_FALSE. (See <B>gluTessNormal()</B> to see how to control the winding direction of the contours.)</I> </DD>
<I><DD>If </I><VAR>property</VAR><I> is GLU_TESS_TOLERANCE, </I><VAR>value</VAR><I> is a distance used to calculate whether two vertices are close together enough to be merged by the GLU_TESS_COMBINE callback. The tolerance value is multiplied by the largest coordinate magnitude of an input vertex to determine the maximum distance any feature can move as a result of a single merge operation. Feature merging may not be supported by your implementation, and the tolerance value is only a hint. The default tolerance value is zero.</I> </DD>
<I><DD>The GLU_TESS_WINDING_RULE </I><VAR>property</VAR><I> determines which parts of the polygon are on the interior and which are the exterior and should not be filled. </I><VAR>value</VAR><I> can be one of GLU_TESS_WINDING_ODD (the default), GLU_TESS_WINDING_NONZERO, GLU_TESS_WINDING_POSITIVE, GLU_TESS_WINDING_NEGATIVE, or GLU_TESS_WINDING_ABS_GEQ_TWO.</DD>
</DL>
</I><H4>Winding Numbers and Winding Rules</H4>
<P>For a single contour, the winding number of a point is the signed number of revolutions we make around that point while traveling once around the contour (where a counterclockwise revolution is positive and a clockwise revolution is negative). When there are several contours, the individual winding numbers are summed. This procedure associates a signed integer value with each point in the plane. Note that the winding number is the same for all points in a single region. </P>
<P>Figure 11-2 shows three sets of contours and winding numbers for points inside those contours. In the left set, all three contours are counterclockwise, so each nested interior region adds one to the winding number. For the middle set, the two interior contours are drawn clockwise, so the winding number decreases and actually becomes negative. </P>
<P><IMG SRC="images/Image127.gif"></P>
<B><P>Figure 11-2 : </B>Winding Numbers for Sample Contours </P>

<P>The winding rule classifies a region as <I>inside</I> if its winding number belongs to the chosen category (odd, nonzero, positive, negative, or "absolute value of greater than or equal to two"). The odd and nonzero rules are common ways to define the interior. The positive, negative, and "absolute value&gt;=2" winding rules have some limited use for polygon CSG (computational solid geometry) operations. </P>
<P>The program tesswind.c demonstrates the effects of winding rules. The four sets of contours shown in Figure 11-3 are rendered. The user can then cycle through the different winding rule properties to see their effects. For each winding rule, the dark areas represent interiors. Note the effect of clockwise and counterclockwise winding. </P>
<P><IMG SRC="images/Image128.gif"></P>
<B><P>Figure 11-3 : </B>How Winding Rules Define Interiors </P>
<P>&nbsp;</P>
<H4>CSG Uses for Winding Rules</H4>
<P>GLU_TESS_WINDING_ODD and GLU_TESS_WINDING_NONZERO are the most commonly used winding rules. They work for the most typical cases of shading. </P>
<P>The winding rules are also designed for computational solid geometry (CSG) operations. Thy make it easy to find the union, difference, or intersection (Boolean operations) of several contours. </P>
<P>First, assume that each contour is defined so that the winding number is zero for each exterior region and one for each interior region. (Each contour must not intersect itself.) Under this model, counterclockwise contours define the outer boundary of the polygon, and clockwise contours define holes. Contours may be nested, but a nested contour must be oriented oppositely from the contour that contains it. </P>
<P>If the original polygons do not satisfy this description, they can be converted to this form by first running the tessellator with the GLU_TESS_BOUNDARY_ONLY property turned on. This returns a list of contours satisfying the restriction just described. By creating two tessellator objects, the callbacks from one tessellator can be fed directly as input to the other. </P>
<P>Given two or more polygons of the preceding form, CSG operations can be implemented as follows. </P>

<UL>
<LI>UNION - To calculate the union of several contours, draw all input contours as a single polygon. The winding number of each resulting region is the number of original polygons that cover it. The union can be extracted by using the GLU_TESS_WINDING_NONZERO or GLU_TESS_WINDING_POSITIVE winding rules. Note that with the nonzero winding rule, we would get the same result if all contour orientations were reversed.<BR>
</LI>
<LI>INTERSECTION - This only works for two contours at a time. Draw a single polygon using two contours. Extract the result using GLU_TESS_WINDING_ABS_GEQ_TWO.<BR>
</LI>
<LI>DIFFERENCE - Suppose you want to compute A diff (B union C union D). Draw a single polygon consisting of the unmodified contours from A, followed by the contours of B, C, and D, with their vertex order reversed. To extract the result, use the GLU_TESS_WINDING_POSITIVE winding rule. (If B, C, and D are the result of a GLU_TESS_BOUNDARY_ONLY operation, an alternative to reversing the vertex order is to use <B>gluTessNormal()</B> to reverse the sign of the supplied normal.</LI></UL>

<H4>Other Tessellation Property Routines</H4>
<P>There are complementary routines, which work alongside <B>gluTessProperty()</B>. <B>gluGetTessProperty()</B> retrieves the current values of tessellator properties. If the tessellator is being used to generate wire frame outlines instead of filled polygons, <B>gluTessNormal()</B> can be used to determine the winding direction of the tessellated polygons. </P>
<I><DL>
<DT>void <B>gluGetTessProperty</B>(GLUtesselator *</I><VAR>tessobj</VAR><I>, GLenum </I><VAR>property</VAR><I>, <BR>
GLdouble *</I><VAR>value</VAR><I>);</I> </DT>
<I><DD>For the tessellation object </I><VAR>tessobj</VAR><I>, the current value of </I><VAR>property</VAR><I> is returned to </I><VAR>value</VAR><I>. Values for </I><VAR>property</VAR><I> and </I><VAR>value</VAR><I> are the same as for <B>gluTessProperty()</B>.</I> </DD>
<I><DT>void <B>gluTessNormal</B>(GLUtesselator *</I><VAR>tessobj</VAR><I>, GLdouble </I><VAR>x</VAR><I>, GLdouble </I><VAR>y</VAR><I>,<BR>
GLdouble </I><VAR>z</VAR><I>);</I> </DT>
<I><DD>For the tessellation object </I><VAR>tessobj</VAR><I>, <B>gluTessNormal()</B> defines a normal vector, which controls the winding direction of generated polygons. Before tessellation, all input data is projected into a plane perpendicular to the normal. Then, all output triangles are oriented counterclockwise, with respect to the normal. (Clockwise orientation can be obtained by reversing the sign of the supplied normal.) The default normal is (0, 0, 0).</DD>
</DL>
</I><P>If you have some knowledge about the location and orientation of the input data, then using <B>gluTessNormal()</B> can increase the speed of the tessellation. For example, if you know that all polygons lie on the x-y plane, call <B>gluTessNormal</B>(<VAR>tessobj</VAR>, 0, 0, 1). </P>
<P>The default normal is (0, 0, 0), and its effect is not immediately obvious. In this case, it is expected that the input data lies approximately in a plane, and a plane is fitted to the vertices, no matter how they are truly connected. The sign of the normal is chosen so that the sum of the signed areas of all input contours is nonnegative (where a counterclockwise contour has a positive area). Note that if the input data does not lie approximately in a plane, then projection perpendicular to the computed normal may substantially change the geometry. </P>
<H3>Polygon Definition</H3>
<P>After all the tessellation properties have been set and the callback actions have been registered, it is finally time to describe the vertices that compromise input contours and tessellate the polygons. </P>
<I><DL>
<DT>void <B>gluTessBeginPolygon </B>(GLUtesselator *</I><VAR>tessobj</VAR><I>, void *</I><VAR>user_data</VAR><I>);<BR>
void <B>gluTessEndPolygon </B>(GLUtesselator *</I><VAR>tessobj</VAR><I>);</I> </DT>
<I><DD>Begins and ends the specification of a polygon to be tessellated and associates a tessellation object, </I><VAR>tessobj</VAR><I>, with it. </I><VAR>user_data</VAR><I> points to a user-defined data structure, which is passed along all the GLU_TESS_*_DATA callback functions that have been bound.</DD>
</DL>
</I><P>Calls to <B>gluTessBeginPolygon()</B> and <B>gluTessEndPolygon()</B> surround the definition of one or more contours. When <B>gluTessEndPolygon()</B> is called, the tessellation algorithm is implemented, and the tessellated polygons are generated and rendered. The callback functions and tessellation properties that were bound and set to the tessellation object using <B>gluTessCallback() </B>and <B>gluTessProperty()</B> are used. </P>
<I><DL>
<DT>void <B>gluTessBeginContour </B>(GLUtesselator *</I><VAR>tessobj</VAR><I>);<BR>
void <B>gluTessEndContour </B>(GLUtesselator *</I><VAR>tessobj</VAR><I>);</I> </DT>
<I><DD>Begins and ends the specification of a closed contour, which is a portion of a polygon. A closed contour consists of zero or more calls to <B>gluTessVertex()</B>, which defines the vertices. The last vertex of each contour is automatically linked to the first.</DD>
</DL>
</I><P>In practice, a minimum of three vertices is needed for a meaningful contour. </P>
<I><DL>
<DT>void <B>gluTessVertex </B>(GLUtesselator *</I><VAR>tessobj</VAR><I>, GLdouble </I><VAR>coords</VAR><I>[3], <BR>
void *</I><VAR>vertex_data</VAR><I>);</I> </DT>
<I><DD>Specifies a vertex in the current contour for the tessellation object. </I><VAR>coords</VAR><I> contains the three-dimensional vertex coordinates, and </I><VAR>vertex_data</VAR><I> is a pointer that's sent to the callback associated with GLU_TESS_VERTEX or GLU_TESS_VERTEX_DATA. Typically, </I><VAR>vertex_data</VAR><I> contains vertex coordinates, surface normals, texture coordinates, color information, or whatever else the application may find useful. </DD>
</DL>
</I><P>In the program tess.c, a portion of which is shown in Example 11-3, two polygons are defined. One polygon is a rectangular contour with a triangular hole inside, and the other is a smooth-shaded, self-intersecting, five-pointed star. For efficiency, both polygons are stored in display lists. The first polygon consists of two contours; the outer one is wound counterclockwise, and the "hole" is wound clockwise. For the second polygon, the <VAR>star</VAR> array contains both the coordinate and color data, and its tessellation callback, <B>vertexCallback()</B>, uses both. </P>
<P>It is important that each vertex is in a different memory location because the vertex data is not copied by <B>gluTessVertex()</B>; only the pointer (<VAR>vertex_data</VAR>) is saved. A program that reuses the same memory for several vertices may not get the desired result. </P>
<B><P>Note: </B>In <B>gluTessVertex()</B>, it may seem redundant to specify the vertex coordinate data twice, for both the <VAR>coords</VAR> and <VAR>vertex_data</VAR> parameters; however, both are necessary. <VAR>coords</VAR> refers only to the vertex coordinates. <VAR>vertex_data</VAR> uses the coordinate data, but may also use other information for each vertex. </P>

<B><P>Example 11-3 : </B>Polygon Definition: tess.c</P>
<PRE>   GLdouble rect[4][3] = {50.0, 50.0, 0.0,
                          200.0, 50.0, 0.0,
                          200.0, 200.0, 0.0,
                          50.0, 200.0, 0.0};
   GLdouble tri[3][3] = {75.0, 75.0, 0.0,
                         125.0, 175.0, 0.0,
                         175.0, 75.0, 0.0};
   GLdouble star[5][6] = {250.0, 50.0, 0.0, 1.0, 0.0, 1.0,
                          325.0, 200.0, 0.0, 1.0, 1.0, 0.0,
                          400.0, 50.0, 0.0, 0.0, 1.0, 1.0,
                          250.0, 150.0, 0.0, 1.0, 0.0, 0.0,
                          400.0, 150.0, 0.0, 0.0, 1.0, 0.0};

   startList = glGenLists(2);
   tobj = gluNewTess();
   gluTessCallback(tobj, GLU_TESS_VERTEX,
                   (GLvoid (*) ()) &amp;glVertex3dv);
   gluTessCallback(tobj, GLU_TESS_BEGIN,
                   (GLvoid (*) ()) &amp;beginCallback);
   gluTessCallback(tobj, GLU_TESS_END,
                   (GLvoid (*) ()) &amp;endCallback);
   gluTessCallback(tobj, GLU_TESS_ERROR,
                   (GLvoid (*) ()) &amp;errorCallback);

   glNewList(startList, GL_COMPILE);
   glShadeModel(GL_FLAT);
   gluTessBeginPolygon(tobj, NULL);
      gluTessBeginContour(tobj);
         gluTessVertex(tobj, rect[0], rect[0]);
         gluTessVertex(tobj, rect[1], rect[1]);
         gluTessVertex(tobj, rect[2], rect[2]);
         gluTessVertex(tobj, rect[3], rect[3]);
      gluTessEndContour(tobj);
      gluTessBeginContour(tobj);
         gluTessVertex(tobj, tri[0], tri[0]);
         gluTessVertex(tobj, tri[1], tri[1]);
         gluTessVertex(tobj, tri[2], tri[2]);
      gluTessEndContour(tobj);
   gluTessEndPolygon(tobj);
   glEndList();

   gluTessCallback(tobj, GLU_TESS_VERTEX,
                   (GLvoid (*) ()) &amp;vertexCallback);
   gluTessCallback(tobj, GLU_TESS_BEGIN,
                   (GLvoid (*) ()) &amp;beginCallback);
   gluTessCallback(tobj, GLU_TESS_END,
                   (GLvoid (*) ()) &amp;endCallback);
   gluTessCallback(tobj, GLU_TESS_ERROR,
                   (GLvoid (*) ()) &amp;errorCallback);
   gluTessCallback(tobj, GLU_TESS_COMBINE,
                   (GLvoid (*) ()) &amp;combineCallback);

   glNewList(startList + 1, GL_COMPILE);
   glShadeModel(GL_SMOOTH);
   gluTessProperty(tobj, GLU_TESS_WINDING_RULE,
                   GLU_TESS_WINDING_POSITIVE);
   gluTessBeginPolygon(tobj, NULL);
      gluTessBeginContour(tobj);
         gluTessVertex(tobj, star[0], star[0]);
         gluTessVertex(tobj, star[1], star[1]);
         gluTessVertex(tobj, star[2], star[2]);
         gluTessVertex(tobj, star[3], star[3]);
         gluTessVertex(tobj, star[4], star[4]);
      gluTessEndContour(tobj);
   gluTessEndPolygon(tobj);
   glEndList();</PRE>
<H3>Deleting a Tessellator Object</H3>
<P>If you no longer need a tessellation object, you can delete it and free all associated memory with <B>gluDeleteTess()</B>. </P>
<I><DL>
<DT>void <B>gluDeleteTess</B>(GLUtesselator *</I><VAR>tessobj</VAR><I>);</I> </DT>
<I><DD>Deletes the specified tessellation object, </I><VAR>tessobj</VAR><I>, and frees all associated memory.</DD>
</DL>
</I><H3>Tessellator Performance Tips</H3>
<P>For best performance, remember these rules. </P><DIR>
<DIR>

<P>Cache the output of the tessellator in a display list or other user structure. To obtain the post-tessellation vertex coordinates, tessellate the polygons while in feedback mode. (See <A HREF="chapter13.html#name2">"Feedback" in Chapter 13</A>.)<BR>
</P>
<P>Use <B>gluTessNormal()</B> to supply the polygon normal.<BR>
</P>
<P>Use the same tessellator object to render many polygons rather than allocate a new tessellator for each one. (In a multithreaded, multiprocessor environment, you may get better performance using several tessellators.)</P></DIR>
</DIR>

<a name = name3>
<H3>Describing GLU Errors</H3>
<P>The GLU provides a routine for obtaining a descriptive string for an error code. This routine is not limited to tessellation but is also used for NURBS and quadrics errors, as well as errors in the base GL. (See <A HREF="chapter14.html#name1">"Error Handling" in Chapter 14</A> for information about OpenGL's error handling facility.) </P>
<H3>Backward Compatibility</H3>
<P>If you are using the 1.0 or 1.1 version of GLU, you have a much less powerful tessellator available. The 1.0/1.1 tessellator handles only simple nonconvex polygons or simple polygons containing holes. It does not properly tessellate intersecting contours (no COMBINE callback), nor process per-polygon data. </P>
<P>The 1.0/1.1 tessellator has some similarities to the current tessellator. <B>gluNewTess()</B> and <B>gluDeleteTess()</B> are used for both tessellators. The main vertex specification routine remains <B>gluTessVertex()</B>. The callback mechanism is controlled by <B>gluTessCallback()</B>, although there are only five callback functions that can be registered, a subset of the current twelve. </P>
<P>Here are the prototypes for the 1.0/1.1 tessellator. The 1.0/1.1 tessellator still works in GLU 1.2, but its use is no longer recommended. </P>
<I><DL>
<DT>void <B>gluBeginPolygon</B>(GLUtriangulatorObj *</I><VAR>tessobj</VAR><I>);<BR>
void <B>gluNextContour</B>(GLUtriangulatorObj *</I><VAR>tessobj</VAR><I>, GLenum </I><VAR>type</VAR><I>);<BR>
void <B>gluEndPolygon</B>(GLUtriangulatorObj *</I><VAR>tessobj</VAR><I>);</I> </DT>
<I><DD>The outermost contour must be specified first, and it does not require an initial call to <B>gluNextContour()</B>. For polygons without holes, only one contour is defined, and <B>gluNextContour()</B> is not used. If a polygon has multiple contours (that is, holes or holes within holes), the contours are specified one after the other, each preceded by <B>gluNextContour()</B>. <B>gluTessVertex()</B> is called for each vertex of a contour.</I> </DD>
<I><DD>For <B>gluNextContour()</B>, type can be GLU_EXTERIOR, GLU_INTERIOR, GLU_CCW, GLU_CW, or GLU_UNKNOWN. These serve only as hints to the tessellation. If you get them right, the tessellation might go faster. If you get them wrong, they're ignored, and the tessellation still works. For polygons with holes, one contour is the exterior contour and the other's interior. The first contour is assumed to be of type GLU_EXTERIOR. Choosing clockwise and counterclockwise orientation is arbitrary in three dimensions; however, there are two different orientations in any plane, and the GLU_CCW and GLU_CW types should be used consistently. Use GLU_UNKNOWN if you don't have a clue.</DD>
</DL>
</I><P>It is highly recommended that you convert GLU 1.0/1.1 code to the new tessellation interface for GLU 1.2 by following these steps. </P><DIR>
<DIR>

<P>Change references to the major data structure type from GLUtriangulatorObj to GLUtesselator. In GLU 1.2, GLUtriangulatorObj and GLUtesselator are defined to be the same type.<BR>
</P>
<P>Convert <B>gluBeginPolygon()</B> to two commands: <B>gluTessBeginPolygon()</B> and <B>gluTessBeginContour()</B>. All contours must be explicitly started, including the first one.<BR>
</P>
<P>Convert <B>gluNextContour()</B> to both <B>gluTessEndContour()</B> and <B>gluTessBeginContour()</B>. You have to end the previous contour before starting the next one.<BR>
</P>
<P>Convert <B>gluEndPolygon()</B> to both <B>gluTessEndContour()</B> and <B>gluTessEndPolygon()</B>. The final contour must be closed.<BR>
</P>
<P>Change references to constants to <B>gluTessCallback()</B>. In GLU 1.2, GLU_BEGIN, GLU_VERTEX, GLU_END, GLU_ERROR, and GLU_EDGE_FLAG are defined as synonyms for GLU_TESS_BEGIN, GLU_TESS_VERTEX, GLU_TESS_END, GLU_TESS_ERROR, and GLU_TESS_EDGE_FLAG.</P>
</DIR>
</DIR>

<br>
<a name = name2>
<H2>Quadrics: Rendering Spheres, Cylinders, and Disks</H2>
<P>The base OpenGL library only provides support for modeling and rendering simple points, lines, and convex filled polygons. Neither 3D objects, nor commonly used 2D objects such as circles, are directly available. </P>
<P>Throughout this book, you've been using GLUT to create some 3D objects. The GLU also provides routines to model and render tessellated, polygonal approximations for a variety of 2D and 3D shapes (spheres, cylinders, disks, and parts of disks), which can be calculated with quadric equations. This includes routines to draw the quadric surfaces in a variety of styles and orientations. Quadric surfaces are defined by the following general quadratic equation: </P>
<I><P>a</I>1<I>x</I>2<I> + a</I>2<I>y</I>2<I> + a</I>3<I>z</I>2<I> + a</I>4<I>xy + a</I>5<I>yx + a</I>6<I>xz + a</I>7<I>x + a</I>8<I>y + a</I>9<I>z + a</I>10<I> = 0</I> </P>
<P>(See David Rogers' <I>Procedural Elements for Computer Graphics.</I> New York, NY: McGraw-Hill Book Company, 1985.<I>)</I> Creating and rendering a quadric surface is similar to using the tessellator. To use a quadrics object, follow these steps. </P><DIR>
<DIR>

<P>To create a quadrics object, use <B>gluNewQuadric()</B>.<BR>
</P>
<P>Specify the rendering attributes for the quadrics object (unless you're satisfied with the default values). </P><DIR>
<DIR>

<P>Use <B>gluQuadricOrientation()</B> to control the winding direction and differentiate the interior from the exterior.<BR>
</P>
<P>Use <B>gluQuadricDrawStyle()</B> to choose between rendering the object as points, lines, or filled polygons. <BR>
</P>
<P>For lit quadrics objects, use <B>gluQuadricNormals()</B> to specify one normal per vertex or one normal per face. The default is that no normals are generated at all.<BR>
</P>
<P>For textured quadrics objects, use <B>gluQuadricTexture()</B> if you want to generate texture coordinates.</P></DIR>
</DIR>

<P>Prepare for problems by registering an error-handling routine with <B>gluQuadricCallback()</B>. Then, if an error occurs during rendering, the routine you've specified is invoked.<BR>
</P>
<P>Now invoke the rendering routine for the desired type of quadrics object:<B> gluSphere()</B>, <B>gluCylinder()</B>, <B>gluDisk()</B>, or <B>gluPartialDisk()</B>. For best performance for static data, encapsulate the quadrics object in a display list.<BR>
</P>
<P>When you're completely finished with it, destroy this object with <B>gluDeleteQuadric()</B>. If you need to create another quadric, it's best to reuse your quadrics object.</P></DIR>
</DIR>

<H3>Manage Quadrics Objects</H3>
<P>A quadrics object consists of parameters, attributes, and callbacks that are stored in a data structure of type GLUquadricObj. A quadrics object may generate vertices, normals, texture coordinates, and other data, all of which may be used immediately or stored in a display list for later use. The following routines create, destroy, and report upon errors of a quadrics object. </P>
<I><DL>
<DT>GLUquadricObj* <B>gluNewQuadric</B> (void);</I> </DT>
<I><DD>Creates a new quadrics object and returns a pointer to it. A null pointer is returned if the routine fails.</I> </DD>
<I><DT>void <B>gluDeleteQuadric</B> (GLUquadricObj *</I><VAR>qobj</VAR><I>);</I> </DT>
<I><DD>Destroys the quadrics object </I><VAR>qobj</VAR><I> and frees up any memory used by it.</I> </DD>
<I><DT>void <B>gluQuadricCallback</B> (GLUquadricObj *</I><VAR>qobj</VAR><I>, GLenum </I><VAR>which</VAR><I>, void (*</I><VAR>fn</VAR><I>)());</I> </DT>
<I><DD>Defines a function </I><VAR>fn</VAR><I> to be called in special circumstances. GLU_ERROR is the only legal value for </I><VAR>which</VAR><I>, so </I><VAR>fn</VAR><I> is called when an error occurs. If </I><VAR>fn</VAR><I> is NULL, any existing callback is erased.</DD>
</DL>
</I><P>For GLU_ERROR, <VAR>fn</VAR> is called with one parameter, which is the error code. <B>gluErrorString()</B> can be used to convert the error code into an ASCII string. </P>
<H3>Control Quadrics Attributes</H3>
<P>The following routines affect the kinds of data generated by the quadrics routines. Use these routines before you actually specify the primitives. </P>
<P>Example 11-4, quadric.c, on page 435, demonstrates changing the drawing style and the kind of normals generated as well as creating quadrics objects, error handling, and drawing the primitives. </P>
<I><DL>
<DT>void <B>gluQuadricDrawStyle</B> (GLUquadricObj *</I><VAR>qobj</VAR><I>, GLenum </I><VAR>drawStyle</VAR><I>); </DT>
<DD>For the quadrics object </I><VAR>qobj</VAR><I>, </I><VAR>drawStyle</VAR><I> controls the rendering style. Legal values for </I><VAR>drawStyle</VAR><I> are GLU_POINT, GLU_LINE, GLU_SILHOUETTE, and GLU_FILL.</DD>
</DL>
</I><P>GLU_POINT and GLU_LINE specify that primitives should be rendered as a point at every vertex or a line between each pair of connected vertices. </P>
<P>GLU_SILHOUETTE specifies that primitives are rendered as lines, except that edges separating coplanar faces are not drawn. This is most often used for <B>gluDisk()</B> and <B>gluPartialDisk()</B>. </P>
<P>GLU_FILL specifies rendering by filled polygons, where the polygons are drawn in a counterclockwise fashion with respect to their normals. This may be affected by <B>gluQuadricOrientation()</B>. </P>
<I><DL>
<DT>void <B>gluQuadricOrientation</B> (GLUquadricObj *</I><VAR>qobj</VAR><I>, GLenum </I><VAR>orientation</VAR><I>);</I> </DT>
<I><DD>For the quadrics object </I><VAR>qobj</VAR><I>, </I><VAR>orientation</VAR><I> is either GLU_OUTSIDE (the default) or GLU_INSIDE, which controls the direction in which normals are pointing. </DD>
</DL>
</I><P>For <B>gluSphere()</B> and <B>gluCylinder()</B>, the definitions of outside and inside are obvious. For <B>gluDisk()</B> and <B>gluPartialDisk()</B>, the positive <I>z</I> side of the disk is considered to be outside. </P>
<I><DL>
<DT>void <B>gluQuadricNormals</B> (GLUquadricObj *</I><VAR>qobj</VAR><I>, GLenum </I><VAR>normals</VAR><I>);</I> </DT>
<I><DD>For the quadrics object </I><VAR>qobj</VAR><I>, </I><VAR>normals</VAR><I> is one of GLU_NONE (the default), GLU_FLAT, or GLU_SMOOTH.</DD>
</DL>
</I><B><P>gluQuadricNormals()</B> is used to specify when to generate normal vectors. GLU_NONE means that no normals are generated and is intended for use without lighting. GLU_FLAT generates one normal for each facet, which is often best for lighting with flat shading. GLU_SMOOTH generates one normal for every vertex of the quadric, which is usually best for lighting with smooth shading. </P>
<I><DL>
<DT>void <B>gluQuadricTexture</B> (GLUquadricObj *</I><VAR>qobj</VAR><I>, <BR>
GLboolean </I><VAR>textureCoords</VAR><I>); </DT>
<DD>For the quadrics object </I><VAR>qobj</VAR><I>, </I><VAR>textureCoords</VAR><I> is either GL_FALSE (the default) or GL_TRUE. If the value of </I><VAR>textureCoords</VAR><I> is GL_TRUE, then texture coordinates are generated for the quadrics object. The manner in which the texture coordinates are generated varies, depending upon the type of quadrics object rendered.</DD>
</DL>
</I><H3>Quadrics Primitives</H3>
<P>The following routines actually generate the vertices and other data that constitute a quadrics object. In each case, <VAR>qobj</VAR> refers to a quadrics object created by <B>gluNewQuadric()</B>. </P>
<I><DL>
<DT>void <B>gluSphere</B> (GLUquadricObj *</I><VAR>qobj</VAR><I>, GLdouble </I><VAR>radius</VAR><I>,<BR>
GLint </I><VAR>slices</VAR><I>, GLint </I><VAR>stacks</VAR><I>);</I> </DT>
<I><DD>Draws a sphere of the given </I><VAR>radius</VAR><I>, centered around the origin, (0, 0, 0). The sphere is subdivided around the z axis into a number of </I><VAR>slices</VAR><I> (similar to longitude) and along the z axis into a number of </I><VAR>stacks</VAR><I> (latitude).</I> </DD>
<I><DD>If texture coordinates are also generated by the quadrics facility, the t coordinate ranges from 0.0 at z = -radius to 1.0 at z = radius, with t increasing linearly along longitudinal lines. Meanwhile, s ranges from 0.0 at the +y axis, to 0.25 at the +x axis, to 0.5 at the -y axis, to 0.75 at the -x axis, and back to 1.0 at the +y axis.</I> </DD>
<I><DT>void <B>gluCylinder</B> (GLUquadricObj *</I><VAR>qobj</VAR><I>, GLdouble </I><VAR>baseRadius</VAR><I>,<BR>
GLdouble </I><VAR>topRadius</VAR><I>, GLdouble </I><VAR>height</VAR><I>, <BR>
GLint </I><VAR>slices</VAR><I>, GLint </I><VAR>stacks</VAR><I>);</I> </DT>
<I><DD>Draws a cylinder oriented along the z axis, with the base of the cylinder at z = 0 and the top at z = height. Like a sphere, the cylinder is subdivided around the z axis into a number of </I><VAR>slices</VAR><I> and along the z axis into a number of </I><VAR>stacks</VAR><I>. </I><VAR>baseRadius</VAR><I> is the radius of the cylinder at z = 0. </I><VAR>topRadius</VAR><I> is the radius of the cylinder at z = height. If </I><VAR>topRadius</VAR><I> is set to zero, then a cone is generated.</I> </DD>
<I><DD>If texture coordinates are generated by the quadrics facility, then the t coordinate ranges linearly from 0.0 at z = 0 to 1.0 at z = </I><VAR>height</VAR><I>. The s texture coordinates are generated the same way as they are for a sphere.</DD>
</DL>
</I><B><P>Note: </B>The cylinder is not closed at the top or bottom. The disks at the base and at the top are not drawn. </P>
<I><DL>
<DT>void <B>gluDisk</B> (GLUquadricObj *</I><VAR>qobj</VAR><I>, GLdouble </I><VAR>innerRadius</VAR><I>,<BR>
GLdouble </I><VAR>outerRadius</VAR><I>, GLint </I><VAR>slices</VAR><I>, GLint </I><VAR>rings</VAR><I>);</I> </DT>
<I><DD>Draws a disk on the z = 0 plane, with a radius of </I><VAR>outerRadius</VAR><I> and a concentric circular hole with a radius of </I><VAR>innerRadius</VAR><I>. If </I><VAR>innerRadius</VAR><I> is 0, then no hole is created. The disk is subdivided around the z axis into a number of </I><VAR>slices</VAR><I> (like slices of pizza) and also about the z axis into a number of concentric </I><VAR>rings</VAR><I>.</I> </DD>
<I><DD>With respect to orientation, the +z side of the disk is considered to be "outside"; that is, any normals generated point along the +z axis. Otherwise, the normals point along the -z axis.</I> </DD>
<I><DD>If texture coordinates are generated by the quadrics facility, then the texture coordinates are generated linearly such that where R=</I><VAR>outerRadius</VAR><I>, the values for s and t at (R, 0, 0) is (1, 0.5), at (0, R, 0) they are (0.5, 1), at (-R, 0, 0) they are (0, 0.5), and at (0, -R, 0) they are (0.5, 0).</I> </DD>
<I><DT>void <B>gluPartialDisk</B> (GLUquadricObj *</I><VAR>qobj</VAR><I>, GLdouble </I><VAR>innerRadius</VAR><I>,<BR>
GLdouble </I><VAR>outerRadius</VAR><I>, GLint </I><VAR>slices</VAR><I>, GLint </I><VAR>rings</VAR><I>,<BR>
GLdouble </I><VAR>startAngle</VAR><I>, GLdouble </I><VAR>sweepAngle</VAR><I>);</I> </DT>
<I><DD>Draws a partial disk on the z = 0 plane. A partial disk is similar to a complete disk, in terms of </I><VAR>outerRadius</VAR><I>, </I><VAR>innerRadius</VAR><I>, </I><VAR>slices</VAR><I>, and </I><VAR>rings</VAR><I>. The difference is that only a portion of a partial disk is drawn, starting from </I><VAR>startAngle</VAR><I> through </I><VAR>startAngle</VAR><I>+</I><VAR>sweepAngle</VAR><I> (where </I><VAR>startAngle</VAR><I> and </I><VAR>sweepAngle</VAR><I> are measured in degrees, where 0 degrees is along the +y axis, 90 degrees along the +x axis, 180 along the -y axis, and 270 along the -x axis).</I> </DD>
<I><DD>A partial disk handles orientation and texture coordinates in the same way as a complete disk.</DD>
</DL>
</I><B><P>Note: </B>For all quadrics objects, it's better to use the <VAR>*Radius</VAR>, <VAR>height</VAR>, and similar arguments to scale them rather than the <B>glScale*()</B> command so that the unit-length normals that are generated don't have to be renormalized. Set the <VAR>rings</VAR> and <VAR>stacks</VAR> arguments to values other than one to force lighting calculations at a finer granularity, especially if the material specularity is high. </P>
<P>Example 11-4 shows each of the quadrics primitives being drawn, as well as the effects of different drawing styles. </P>

<B><P>Example 11-4 : </B>Quadrics Objects: quadric.c</P>
<PRE>#include &lt;GL/gl.h&gt;
#include &lt;GL/glu.h&gt;
#include &lt;GL/glut.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

GLuint startList;

void errorCallback(GLenum errorCode)
{
   const GLubyte *estring;

   estring = gluErrorString(errorCode);
   fprintf(stderr, "Quadric Error: %s\n", estring);
   exit(0);
}

void init(void) 
{
   GLUquadricObj *qobj;
   GLfloat mat_ambient[] = { 0.5, 0.5, 0.5, 1.0 };
   GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
   GLfloat mat_shininess[] = { 50.0 };
   GLfloat light_position[] = { 1.0, 1.0, 1.0, 0.0 };
   GLfloat model_ambient[] = { 0.5, 0.5, 0.5, 1.0 };

   glClearColor(0.0, 0.0, 0.0, 0.0);

   glMaterialfv(GL_FRONT, GL_AMBIENT, mat_ambient);
   glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
   glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
   glLightfv(GL_LIGHT0, GL_POSITION, light_position);
   glLightModelfv(GL_LIGHT_MODEL_AMBIENT, model_ambient);

   glEnable(GL_LIGHTING);
   glEnable(GL_LIGHT0);
   glEnable(GL_DEPTH_TEST);

/* Create 4 display lists, each with a different quadric object.
 * Different drawing styles and surface normal specifications
 * are demonstrated.
 */
   startList = glGenLists(4);
   qobj = gluNewQuadric();
   gluQuadricCallback(qobj, GLU_ERROR, errorCallback);

   gluQuadricDrawStyle(qobj, GLU_FILL); /* smooth shaded */
   gluQuadricNormals(qobj, GLU_SMOOTH);
   glNewList(startList, GL_COMPILE);
      gluSphere(qobj, 0.75, 15, 10);
   glEndList();

   gluQuadricDrawStyle(qobj, GLU_FILL); /* flat shaded */
   gluQuadricNormals(qobj, GLU_FLAT);
   glNewList(startList+1, GL_COMPILE);
      gluCylinder(qobj, 0.5, 0.3, 1.0, 15, 5);
   glEndList();

   gluQuadricDrawStyle(qobj, GLU_LINE); /* wireframe */
   gluQuadricNormals(qobj, GLU_NONE);
   glNewList(startList+2, GL_COMPILE);
      gluDisk(qobj, 0.25, 1.0, 20, 4);
   glEndList();

   gluQuadricDrawStyle(qobj, GLU_SILHOUETTE);
   gluQuadricNormals(qobj, GLU_NONE);
   glNewList(startList+3, GL_COMPILE);
      gluPartialDisk(qobj, 0.0, 1.0, 20, 4, 0.0, 225.0);
   glEndList();
}

void display(void)
{
   glClear (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   glPushMatrix();

   glEnable(GL_LIGHTING);
   glShadeModel (GL_SMOOTH);
   glTranslatef(-1.0, -1.0, 0.0);
   glCallList(startList);

   glShadeModel (GL_FLAT);
   glTranslatef(0.0, 2.0, 0.0);
   glPushMatrix();
   glRotatef(300.0, 1.0, 0.0, 0.0);
   glCallList(startList+1);
   glPopMatrix();

   glDisable(GL_LIGHTING);
   glColor3f(0.0, 1.0, 1.0);
   glTranslatef(2.0, -2.0, 0.0);
   glCallList(startList+2);

   glColor3f(1.0, 1.0, 0.0);
   glTranslatef(0.0, 2.0, 0.0);
   glCallList(startList+3);

   glPopMatrix();
   glFlush();
}

void reshape (int w, int h)
{
   glViewport(0, 0, (GLsizei) w, (GLsizei) h);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   if (w &lt;= h)
      glOrtho(-2.5, 2.5, -2.5*(GLfloat)h/(GLfloat)w,
         2.5*(GLfloat)h/(GLfloat)w, -10.0, 10.0);
   else
      glOrtho(-2.5*(GLfloat)w/(GLfloat)h,
         2.5*(GLfloat)w/(GLfloat)h, -2.5, 2.5, -10.0, 10.0);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
}

void keyboard(unsigned char key, int x, int y)
{
   switch (key) {
      case 27:
         exit(0);
         break;
   }
}

int main(int argc, char** argv)
{
   glutInit(&amp;argc, argv);
   glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);
   glutInitWindowSize(500, 500); 
   glutInitWindowPosition(100, 100);
   glutCreateWindow(argv[0]);
   init();
   glutDisplayFunc(display); 
   glutReshapeFunc(reshape);
   glutKeyboardFunc(keyboard);
   glutMainLoop();
   return 0;
}</PRE>

<hr size="1" noshade style="color:#226666;">
<center>
<A HREF="chapter10.html"><img src="images/ArrowLeft.gif" border=0></A>
<a href="index.html"><img src="images/ArrowHome.gif" border=0></a>
<A HREF="chapter12.html"><img src="images/ArrowRight.gif" border=0></A>
</center>

</td></tr>
</table>
</div>

</BODY>
</HTML>

