<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html">
<TITLE>Chapter 12 - OpenGL Programming Guide </TITLE>

</HEAD>

<body bgcolor="#ffffff">
<div align="left">
<table border="0" cellpadding="1" cellspacing="0" width="95%" bgcolor="#226666">
<tr><td>
<table border="0" cellpadding="15" cellspacing="0" width="100%" bgcolor="#F2FFF6">
<tr align=center><td>
<font size="4" color="#226666"><b>OpenGL Programming Guide</b></font>
</td></tr>
</table>
</td></tr>
<tr align="right" bgcolor="#ffffff"><td>
 
<a href="./index.html" onMouseOver="status='OpenGL Programming Guide Index';return true" onMouseOut="status=''">
<font color="#000000">Programming Guide</font></a> &gt; 
Chapter 12
</td></tr>
</table>
</div>
<br><br>

<div align="left">
<table border="0" cellpadding="0" cellspacing="0" width="95%">
<tr><td>

<H2>Chapter 12<BR>
Evaluators and NURBS</H2>

<hr size="1" noshade style="color:#226666;">

<B><P>Chapter Objectives</B> </P>
<B><P>Advanced</B> </P>
<P>After reading this chapter, you'll be able to do the following: </P>

<UL>
<LI>Use OpenGL evaluator commands to draw basic curves and surfaces<BR>
</LI>
<LI>Use the GLU's higher-level NURBS facility to draw more complex curves and surfaces</LI></UL>

<P>Note that this chapter presumes a number of prerequisites; they're listed in <A HREF="#name1">"Prerequisites."</A> </P>
<P>At the lowest level, graphics hardware draws points, line segments, and polygons, which are usually triangles and quadrilaterals. Smooth curves and surfaces are drawn by approximating them with large numbers of small line segments or polygons. However, many useful curves and surfaces can be described mathematically by a small number of parameters such as a few <I>control points</I>. Saving the 16 control points for a surface requires much less storage than saving 1000 triangles together with the normal vector information at each vertex. In addition, the 1000 triangles only approximate the true surface, but the control points accurately describe the real surface. </P>
<P>Evaluators provide a way to specify points on a curve or surface (or part of one) using only the control points. The curve or surface can then be rendered at any precision. In addition, normal vectors can be calculated for surfaces automatically. You can use the points generated by an evaluator in many ways - to draw dots where the surface would be, to draw a wireframe version of the surface, or to draw a fully lighted, shaded, and even textured version. </P>
<P>You can use evaluators to describe any polynomial or rational polynomial splines or surfaces of any degree. These include almost all splines and spline surfaces in use today, including B-splines, NURBS (Non-Uniform Rational B-Spline) surfaces, Bezier curves and surfaces, and Hermite splines. Since evaluators provide only a low-level description of the points on a curve or surface, they're typically used underneath utility libraries that provide a higher-level interface to the programmer. The GLU's NURBS facility is such a higher-level interface - the NURBS routines encapsulate lots of complicated code. Much of the final rendering is done with evaluators, but for some conditions (trimming curves, for example) the NURBS routines use planar polygons for rendering. </P>
<P>This chapter contains the following major sections. </P>

<UL>
<LI><A HREF="#name1">"Prerequisites"</A> discusses what knowledge is assumed for this chapter. It also gives several references where you can obtain this information.<BR>
</LI>
<LI><A HREF="#name2">"Evaluators"</A> explains how evaluators work and how to control them using the appropriate OpenGL commands.<BR>
</LI>
<LI><A HREF="#name3">"The GLU NURBS Interface"</A> describes the GLU routines for creating NURBS surfaces.</LI></UL>

<br>
<a name = name1>
<H2>Prerequisites</H2>
<P>Evaluators make splines and surfaces that are based on a Bezier (or Bernstein) basis. The defining formulas for the functions in this basis are given in this chapter, but the discussion doesn't include derivations or even lists of all their interesting mathematical properties. If you want to use evaluators to draw curves and surfaces using other bases, you must know how to convert your basis to a Bezier basis. In addition, when you render a Bezier surface or part of it using evaluators, you need to determine the granularity of your subdivision. Your decision needs to take into account the trade-off between high-quality (highly subdivided) images and high speed. Determining an appropriate subdivision strategy can be quite complicated - too complicated to be discussed here. </P>
<P>Similarly, a complete discussion of NURBS is beyond the scope of this book. The GLU NURBS interface is documented here, and programming examples are provided for readers who already understand the subject. In what follows, you already should know about NURBS control points, knot sequences, and trimming curves. </P>
<P>If you lack some of these prerequisites, the following references will help. </P>

<UL>
<LI>Farin, Gerald E., <I>Curves and Surfaces for Computer-Aided Geometric Design, Fourth Edition</I>. San Diego, CA: Academic Press, 1996.<BR>
</LI>
<LI>Farin, Gerald E., <I>NURB Curves and Surfaces: from Projective Geometry to Practical Use.</I> Wellesley, MA: A. K. Peters Ltd., 1995.<BR>
</LI>
<LI>Farin, Gerald E., editor, <I>NURBS for Curve and Surface Design</I>, Society for Industrial and Applied Mathematics, Philadelphia, PA, 1991.<BR>
</LI>
<LI>Hoschek, Josef and Dieter Lasser, <I>Fundamentals of Computer Aided Geometric Design.</I> Wellesley, MA: A. K. Peters Ltd., 1993.<BR>
</LI>
<LI>Piegl, Les and Wayne Tiller, <I>The NURBS Book</I>. New York, NY: Springer-Verlag, 1995.</LI></UL>

<B><P>Note: </B>Some terms used in this chapter might have slightly different meanings in other books on spline curves and surfaces, since there isn't total agreement among the practitioners of this art. Generally, the OpenGL meanings are a bit more restrictive. For example, OpenGL evaluators always use Bezier bases; in other contexts, evaluators might refer to the same concept, but with an arbitrary basis. </P>

<br>
<a name = name2>
<H2>Evaluators</H2>
<P>A Bezier curve is a vector-valued function of one variable </P>
<B><P>C</B>(<VAR>u</VAR>) = [<B>X</B>(<VAR>u</VAR>) <B>Y</B>(<VAR>u</VAR>) <B>Z</B>(<VAR>u</VAR>)] </P>
<P>where <VAR>u</VAR> varies in some domain (say [0,1]). A Bezier surface patch is a vector-valued function of two variables </P>
<B><P>S</B>(<VAR>u,v</VAR>) = [<B>X</B>(<VAR>u,v</VAR>) <B>Y</B>(<VAR>u,v</VAR>) <B>Z</B>(<VAR>u,v</VAR>)] </P>
<P>where <VAR>u</VAR> and <VAR>v</VAR> can both vary in some domain. The range isn't necessarily three-dimensional as shown here. You might want two-dimensional output for curves on a plane or texture coordinates, or you might want four-dimensional output to specify RGBA information. Even one-dimensional output may make sense for gray levels. </P>
<P>For each <VAR>u</VAR> (or <VAR>u</VAR> and <VAR>v</VAR>, in the case of a surface), the formula for <B>C()</B> (or <B>S()</B>) calculates a point on the curve (or surface). To use an evaluator, first define the function <B>C()</B> or <B>S()</B>, enable it, and then use the <B>glEvalCoord1()</B> or <B>glEvalCoord2()</B> command instead of <B>glVertex*()</B>. This way, the curve or surface vertices can be used like any other vertices - to form points or lines, for example. In addition, other commands automatically generate series of vertices that produce a regular mesh uniformly spaced in <VAR>u</VAR> (or in <VAR>u</VAR> and <VAR>v</VAR>). One- and two-dimensional evaluators are similar, but the description is somewhat simpler in one dimension, so that case is discussed first. </P>
<H3>One-Dimensional Evaluators</H3>
<P>This section presents an example of using one-dimensional evaluators to draw a curve. It then describes the commands and equations that control evaluators. </P>
<H4>One-Dimensional Example: A Simple Bezier Curve</H4>
<P>The program shown in Example 12-1 draws a cubic Bezier curve using four control points, as shown in Figure 12-1. </P>
<P><IMG SRC="images/Image129.gif"></P>
<B><P>Figure 12-1 : </B>Bezier Curve </P>

<B><P>Example 12-1 : </B>Bezier Curve with Four Control Points: bezcurve.c</P>
<PRE>#include &lt;GL/gl.h&gt;
#include &lt;GL/glu.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;GL/glut.h&gt;

GLfloat ctrlpoints[4][3] = {
        { -4.0, -4.0, 0.0}, { -2.0, 4.0, 0.0}, 
        {2.0, -4.0, 0.0}, {4.0, 4.0, 0.0}};

void init(void)
{
   glClearColor(0.0, 0.0, 0.0, 0.0);
   glShadeModel(GL_FLAT);
   glMap1f(GL_MAP1_VERTEX_3, 0.0, 1.0, 3, 4, &amp;ctrlpoints[0][0]);
   glEnable(GL_MAP1_VERTEX_3);
}

void display(void)
{
   int i;

   glClear(GL_COLOR_BUFFER_BIT);
   glColor3f(1.0, 1.0, 1.0);
   glBegin(GL_LINE_STRIP);
      for (i = 0; i &lt;= 30; i++) 
         glEvalCoord1f((GLfloat) i/30.0);
   glEnd();
   /* The following code displays the control points as dots. */
   glPointSize(5.0);
   glColor3f(1.0, 1.0, 0.0);
   glBegin(GL_POINTS);
      for (i = 0; i &lt; 4; i++) 
         glVertex3fv(&amp;ctrlpoints[i][0]);
   glEnd();
   glFlush();
}

void reshape(int w, int h)
{
   glViewport(0, 0, (GLsizei) w, (GLsizei) h);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   if (w &lt;= h)
      glOrtho(-5.0, 5.0, -5.0*(GLfloat)h/(GLfloat)w, 
               5.0*(GLfloat)h/(GLfloat)w, -5.0, 5.0);
   else
      glOrtho(-5.0*(GLfloat)w/(GLfloat)h, 
               5.0*(GLfloat)w/(GLfloat)h, -5.0, 5.0, -5.0, 5.0);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
}

int main(int argc, char** argv)
{
   glutInit(&amp;argc, argv);
   glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB);
   glutInitWindowSize (500, 500);
   glutInitWindowPosition (100, 100);
   glutCreateWindow (argv[0]);
   init ();
   glutDisplayFunc(display);
   glutReshapeFunc(reshape);
   glutMainLoop();
   return 0;
}
</PRE>
<P>A cubic Bezier curve is described by four control points, which appear in this example in the <VAR>ctrlpoints[][]</VAR> array. This array is one of the arguments to <B>glMap1f()</B>. All the arguments for this command are as follows: </P>
<DL>
<DT>GL_MAP1_VERTEX_3   Three-dimensional control points are provided and three-dimensional vertices are produced </DT>
<DT>0.0   Low value of parameter <VAR>u</VAR> </DT>
<DT>1.0   High value of parameter <VAR>u</VAR> </DT>
<DT>3   The number of floating-point values to advance in the data between one control point and the next </DT>
<DT>4   The order of the spline, which is the degree+1: in this case, the degree is 3 (since this is a cubic curve) </DT>
<VAR><DT>&amp;ctrlpoints[0][0]</VAR>   Pointer to the first control point's data</DT>
</DL>
<P>Note that the second and third arguments control the parameterization of the curve - as the variable <VAR>u</VAR> ranges from 0.0 to 1.0, the curve goes from one end to the other. The call to <B>glEnable()</B> enables the one-dimensional evaluator for three-dimensional vertices. </P>
<P>The curve is drawn in the routine <B>display() </B>between the <B>glBegin() </B>and <B>glEnd()</B> calls. Since the evaluator is enabled, the command <B>glEvalCoord1f()</B> is just like issuing a <B>glVertex()</B> command with the coordinates of a vertex on the curve corresponding to the input parameter <VAR>u</VAR>. </P>
<H4>Defining and Evaluating a One-Dimensional Evaluator </H4>
<P>The Bernstein polynomial of degree <VAR>n</VAR> (or order <VAR>n</VAR>+1) is given by </P>
<P><IMG SRC="images/Image130.gif"></P>
<P>If Pi represents a set of control points (one-, two-, three-, or even four- dimensional), then the equation </P>
<P><IMG SRC="images/Image131.gif"></P>
<P>represents a Bezier curve as <VAR>u</VAR> varies from 0.0 to 1.0. To represent the same curve but allowing <VAR>u</VAR> to vary between <VAR>u</VAR>1 and <VAR>u</VAR>2 instead of 0.0 and 1.0, evaluate </P>
<P><IMG SRC="images/Image132.gif"></P>
<P>The command <B>glMap1()</B> defines a one-dimensional evaluator that uses these equations. </P>
<I><DL>
<DT>void <B>glMap1</B>{fd}(GLenum </I><VAR>target</VAR><I>, </I><VAR>TYPEu1</VAR><I>, </I><VAR>TYPE</VAR><I>u2, GLint </I><VAR>stride</VAR><I>, <BR>
GLint </I><VAR>order</VAR><I>, </I><VAR>const TYPE*points</VAR><I>); </DT>
<DD>Defines a one-dimensional evaluator. The </I><VAR>target</VAR><I> parameter specifies what the control points represent, as shown in </I><I>Table 12-1</I><I>, and therefore how many values need to be supplied in </I><VAR>points</VAR><I>. The points can represent vertices, RGBA color data, normal vectors, or texture coordinates. For</I> </DD>
<I><DD>example, with GL_MAP1_COLOR_4, the evaluator generates color data along a curve in four-dimensional (RGBA) color space. You also use the parameter values listed in </I><I>Table 12-1</I><I> to enable each defined evaluator before you invoke it. Pass the appropriate value to <B>glEnable()</B> or <B>glDisable()</B> to enable or disable the evaluator.</I> </DD>
<I><DD>The second two parameters for <B>glMap1*()</B>, u1 and u2, indicate the range for the variable </I><VAR>u</VAR><I>. The variable </I><VAR>stride</VAR><I> is the number of single- or double-precision values (as appropriate) in each block of storage. Thus, it's an offset value between the beginning of one control point and the beginning of the next. </DD>
<DD>The </I><VAR>order</VAR><I> is the degree plus one, and it should agree with the number of control points. The </I><VAR>points</VAR><I> parameter points to the first coordinate of the first control point. Using the example data structure for <B>glMap1*()</B>, use the following for </I><VAR>points</VAR><I>:</DD>
</DL>
</I><PRE>(GLfloat *)(&amp;ctlpoints[0].x)

<B>Table 12-1 : </B>Types of Control Points for glMap1*()</PRE>
<TABLE BORDER CELLSPACING=1 CELLPADDING=8 WIDTH=406>
<TR><TD WIDTH="53%" VALIGN="TOP">
<P ALIGN="CENTER"><B>Parameter</B></TD>
<TD WIDTH="47%" VALIGN="TOP">
<B><P ALIGN="CENTER">Meaning</B></TD>
</TR>
<TR><TD WIDTH="53%" VALIGN="TOP">
<P>GL_MAP1_VERTEX_3</TD>
<TD WIDTH="47%" VALIGN="TOP">
<VAR><P>x, y, z</VAR> vertex coordinates</TD>
</TR>
<TR><TD WIDTH="53%" VALIGN="TOP">
<P>GL_MAP1_VERTEX_4</TD>
<TD WIDTH="47%" VALIGN="TOP">
<VAR><P>x, y, z, w </VAR>vertex coordinates</TD>
</TR>
<TR><TD WIDTH="53%" VALIGN="TOP">
<P>GL_MAP1_INDEX</TD>
<TD WIDTH="47%" VALIGN="TOP">
<P>color index</TD>
</TR>
<TR><TD WIDTH="53%" VALIGN="TOP">
<P>GL_MAP1_COLOR_4</TD>
<TD WIDTH="47%" VALIGN="TOP">
<P>R, G, B, A</TD>
</TR>
<TR><TD WIDTH="53%" VALIGN="TOP">
<P>GL_MAP1_NORMAL</TD>
<TD WIDTH="47%" VALIGN="TOP">
<P>normal coordinates</TD>
</TR>
<TR><TD WIDTH="53%" VALIGN="TOP">
<P>GL_MAP1_TEXTURE_COORD_1</TD>
<TD WIDTH="47%" VALIGN="TOP">
<VAR><P>s</VAR> texture coordinates</TD>
</TR>
<TR><TD WIDTH="53%" VALIGN="TOP">
<P>GL_MAP1_TEXTURE_COORD_2</TD>
<TD WIDTH="47%" VALIGN="TOP">
<VAR><P>s, t</VAR> texture coordinates</TD>
</TR>
<TR><TD WIDTH="53%" VALIGN="TOP">
<P>GL_MAP1_TEXTURE_COORD_3</TD>
<TD WIDTH="47%" VALIGN="TOP">
<VAR><P>s, t, r</VAR> texture coordinates</TD>
</TR>
<TR><TD WIDTH="53%" VALIGN="TOP">
<P>GL_MAP1_TEXTURE_COORD_4</TD>
<TD WIDTH="47%" VALIGN="TOP">
<VAR><P>s, t, r, q</VAR> texture coordinates</TD>
</TR>
</TABLE>


<P>More than one evaluator can be evaluated at a time. If you have both a GL_MAP1_VERTEX_3 and a GL_MAP1_COLOR_4 evaluator defined and enabled, for example, then calls to <B>glEvalCoord1()</B> generate both a position and a color. Only one of the vertex evaluators can be enabled at a time, although you might have defined both of them. Similarly, only one of the texture evaluators can be active. Other than that, however, evaluators can be used to generate any combination of vertex, normal, color, and texture-coordinate data. If more than one evaluator of the same type is defined and enabled, the one of highest dimension is used. </P>
<P>Use<B> glEvalCoord1*()</B> to evaluate a defined and enabled one-dimensional map. </P>
<I><DL>
<DT>void <B>glEvalCoord1</B>{fd}(</I><VAR>TYPE u</VAR><I>);<BR>
void <B>glEvalCoord1</B>{fd}<B>v</B>(</I><VAR>TYPE *u</VAR><I>);</I> </DT>
<I><DD>Causes evaluation of the enabled one-dimensional maps. The argument </I><VAR>u</VAR><I> is the value (or a pointer to the value, in the vector version of the command) of the domain coordinate.</DD>
</DL>
</I><P>For evaluated vertices, values for color, color index, normal vectors, and texture coordinates are generated by evaluation. Calls to <B>glEvalCoord*()</B> do not use the current values for color, color index, normal vectors, and texture coordinates. <B>glEvalCoord*()</B> also leaves those values unchanged. </P>
<H4>Defining Evenly Spaced Coordinate Values in One Dimension</H4>
<P>You can use <B>glEvalCoord1()</B> with any values for <VAR>u</VAR>, but by far the most common use is with evenly spaced values, as shown previously in Example 12-1. To obtain evenly spaced values, define a one-dimensional grid using <B>glMapGrid1*()</B> and then apply it using <B>glEvalMesh1()</B>. </P>
<I><DL>
<DT>void <B>glMapGrid1</B>{fd}(GLint </I><VAR>n</VAR><I>, </I><VAR>TYPEu1</VAR><I>, </I><VAR>TYPEu2</VAR><I>); </DT>
<DD>Defines a grid that goes from </I><VAR>u1</VAR><I> to </I><VAR>u2</VAR><I> in </I><VAR>n</VAR><I> steps, which are evenly spaced.</I> </DD>
<I><DT>void <B>glEvalMesh1</B>(GLenum </I><VAR>mode</VAR><I>, GLint </I><VAR>p1</VAR><I>, GLint </I><VAR>p2</VAR><I>);</I> </DT>
<I><DD>Applies the currently defined map grid to all enabled evaluators. The </I><VAR>mode</VAR><I> can be either GL_POINT or GL_LINE, depending on whether you want to draw points or a connected line along the curve. The call has exactly the same effect as issuing a <B>glEvalCoord1()</B> for each of the steps between and including </I><VAR>p1</VAR><I> and </I><VAR>p2</VAR><I>, where 0 &lt;= </I><VAR>p1</VAR><I>, </I><VAR>p2</VAR><I> &lt;= </I><VAR>n</VAR><I>. Programmatically, it's equivalent to the following: </DD>
</DL>
</I><PRE>glBegin(GL_POINTS);    /* OR glBegin(GL_LINE_STRIP); */
 for (i = p1; i &lt;= p2; i++) <BR>
    glEvalCoord1(u1 + i*(u2-u1)/n);<BR>
glEnd();</PRE>
<I><DL>
<DD>except that if </I><VAR>i</VAR><I> = 0 or </I><VAR>i</VAR><I> = </I><VAR>n</VAR><I>, then <B>glEvalCoord1()</B> is called with exactly </I><VAR>u1</VAR><I> or </I><VAR>u2</VAR><I> as its parameter.</DD>
</DL>
</I><H3>Two-Dimensional Evaluators</H3>
<P>In two dimensions, everything is similar to the one-dimensional case, except that all the commands must take two parameters, <VAR>u</VAR> and <VAR>v</VAR>, into account. Points, colors, normals, or texture coordinates must be supplied over a surface instead of a curve. Mathematically, the definition of a Bezier surface patch is given by </P>
<P><IMG SRC="images/Image133.gif"></P>
<P>where <I>P</I>ij are a set of <I>m*n</I> control points, and the <I>B</I>i are the same Bernstein polynomials for one dimension. As before, the <I>P</I>ij can represent vertices, normals, colors, or texture coordinates. </P>
<P>The procedure to use two-dimensional evaluators is similar to the procedure for one dimension. </P><DIR>
<DIR>

<P>Define the evaluator(s) with <B>glMap2*()</B>.<BR>
</P>
<P>Enable them by passing the appropriate value to <B>glEnable()</B>.<BR>
</P>
<P>Invoke them either by calling <B>glEvalCoord2()</B> between a <B>glBegin()</B> and <B>glEnd()</B> pair or by specifying and then applying a mesh with <B>glMapGrid2()</B> and <B>glEvalMesh2()</B>.</P></DIR>
</DIR>

<H4>Defining and Evaluating a Two-Dimensional Evaluator </H4>
<P>Use <B>glMap2*()</B> and <B>glEvalCoord2*()</B> to define and then invoke a two-dimensional evaluator. </P>
<I><DL>
<DT>void <B>glMap2</B>{fd}(GLenum </I><VAR>target</VAR><I>, </I><VAR>TYPEu1</VAR><I>, </I><VAR>TYPEu2</VAR><I>, GLint </I><VAR>ustride</VAR><I>, <BR>
GLint </I><VAR>uorder</VAR><I>,</I><VAR> TYPEv1</VAR><I>, </I><VAR>TYPEv2</VAR><I>, GLint </I><VAR>vstride</VAR><I>, <BR>
GLint </I><VAR>vorder</VAR><I>, </I><VAR>TYPE points</VAR><I>); </DT>
<DD>The </I><VAR>target</VAR><I> parameter can have any of the values in </I><I>Table 12-1</I><I>, except that the string MAP1 is replaced with MAP2. As before, these values are also used with <B>glEnable()</B> to enable the corresponding evaluator. Minimum and maximum values for both </I><VAR>u </VAR><I>and </I><VAR>v</VAR><I> are provided as </I><VAR>u1</VAR><I>, </I><VAR>u2</VAR><I>, </I><VAR>v1</VAR><I>, and </I><VAR>v2</VAR><I>. The parameters </I><VAR>ustride</VAR><I> and </I><VAR>vstride</VAR><I> indicate the number of single- or double-precision values (as appropriate) between independent settings for these values, allowing users to select a subrectangle of control points out of a much larger array. For example, if the data appears in the form</DD>
</DL>
</I><PRE>GLfloat ctlpoints[100][100][3];</PRE>
<I><DL>
<DD><BR>
and you want to use the 4x4 subset beginning at ctlpoints[20][30], choose </I><VAR>ustride</VAR><I> to be 100*3 and </I><VAR>vstride</VAR><I> to be 3. The starting point, </I><VAR>points</VAR><I>, should be set to &amp;ctlpoints[20][30][0]. Finally, the order parameters, </I><VAR>uorder</VAR><I> and </I><VAR>vorder</VAR><I>, can be different, allowing patches that are cubic in one direction and quadratic in the other, for example. </DD>
<DT>void <B>glEvalCoord2</B>{fd}(</I><VAR>TYPE u, TYPE v</VAR><I>); <BR>
void <B>glEvalCoord2</B>{fd}<B>v</B>(</I><VAR>TYPE *values</VAR><I>);</I> </DT>
<I><DD>Causes evaluation of the enabled two-dimensional maps. The arguments </I><VAR>u </VAR><I>and</I><VAR> v</VAR><I> are the values (or a pointer to the </I><VAR>values</VAR><I> u and v, in the vector version of the command) for the domain coordinates. If either of the vertex evaluators is enabled (GL_MAP2_VERTEX_3 or GL_MAP2_VERTEX_4), then the normal to the surface is computed analytically. This normal is associated with the generated vertex if automatic normal generation has been enabled by passing GL_AUTO_NORMAL to <B>glEnable()</B>. If it's disabled, the corresponding enabled normal map is used to produce a normal. If no such map exists, the current normal is used. </DD>
</DL>
</I><H4>Two-Dimensional Example: A Bezier Surface</H4>
<P>Example 12-2 draws a wireframe Bezier surface using evaluators, as shown in Figure 12-2. In this example, the surface is drawn with nine curved lines in each direction. Each curve is drawn as 30 segments. To get the whole program, add the <B>reshape()</B> and <B>main()</B> routines from Example 12-1. </P>
<P><IMG SRC="images/Image134.gif"></P>
<B><P>Figure 12-2 : </B>Bezier Surface </P>

<B><P>Example 12-2 : </B>Bezier Surface: bezsurf.c</P>
<PRE>#include &lt;GL/gl.h&gt;
#include &lt;GL/glu.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;GL/glut.h&gt;

GLfloat ctrlpoints[4][4][3] = {
   {{-1.5, -1.5, 4.0}, {-0.5, -1.5, 2.0}, 
    {0.5, -1.5, -1.0}, {1.5, -1.5, 2.0}}, 
   {{-1.5, -0.5, 1.0}, {-0.5, -0.5, 3.0}, 
    {0.5, -0.5, 0.0}, {1.5, -0.5, -1.0}}, 
   {{-1.5, 0.5, 4.0}, {-0.5, 0.5, 0.0}, 
    {0.5, 0.5, 3.0}, {1.5, 0.5, 4.0}}, 
   {{-1.5, 1.5, -2.0}, {-0.5, 1.5, -2.0}, 
    {0.5, 1.5, 0.0}, {1.5, 1.5, -1.0}}
};

void display(void)
{
   int i, j;

   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   glColor3f(1.0, 1.0, 1.0);
   glPushMatrix ();
   glRotatef(85.0, 1.0, 1.0, 1.0);
   for (j = 0; j &lt;= 8; j++) {
      glBegin(GL_LINE_STRIP);
      for (i = 0; i &lt;= 30; i++)
         glEvalCoord2f((GLfloat)i/30.0, (GLfloat)j/8.0);
      glEnd();
      glBegin(GL_LINE_STRIP);
      for (i = 0; i &lt;= 30; i++)
         glEvalCoord2f((GLfloat)j/8.0, (GLfloat)i/30.0);
      glEnd();
   }
   glPopMatrix ();
   glFlush();
}

void init(void)
{
   glClearColor (0.0, 0.0, 0.0, 0.0);
   glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4,
           0, 1, 12, 4, &amp;ctrlpoints[0][0][0]);
   glEnable(GL_MAP2_VERTEX_3);
   glMapGrid2f(20, 0.0, 1.0, 20, 0.0, 1.0);
   glEnable(GL_DEPTH_TEST);
   glShadeModel(GL_FLAT);
}</PRE>
<H4>Defining Evenly Spaced Coordinate Values in Two Dimensions</H4>
<P>In two dimensions, the <B>glMapGrid2*()</B> and <B>glEvalMesh2()</B> commands are similar to the one-dimensional versions, except that both <VAR>u</VAR> and <VAR>v</VAR> information must be included. </P>
<I><DL>
<DT>void <B>glMapGrid2</B>{fd}(GLint </I><VAR>nu</VAR><I>, </I><VAR>TYPEu1</VAR><I>, </I><VAR>TYPEu2</VAR><I>, <BR>
GLint </I><VAR>nv</VAR><I>, </I><VAR>TYPEv1</VAR><I>, </I><VAR>TYPEv2</VAR><I>); <BR>
void <B>glEvalMesh2</B>(GLenum </I><VAR>mode</VAR><I>, GLint </I><VAR>i1</VAR><I>, GLint </I><VAR>i2</VAR><I>, GLint </I><VAR>j1</VAR><I>, GLint </I><VAR>j2</VAR><I>);</I> </DT>
<I><DD>Defines a two-dimensional map grid that goes from </I><VAR>u1</VAR><I> to </I><VAR>u2</VAR><I> in </I><VAR>nu</VAR><I> evenly spaced steps, from </I><VAR>v1</VAR><I> to </I><VAR>v2</VAR><I> in </I><VAR>nv</VAR><I> steps (<B>glMapGrid2*()</B>), and then applies this grid to all enabled evaluators (<B>glEvalMesh2()</B>). The only significant difference from the one-dimensional versions of these two commands is that in <B>glEvalMesh2()</B> the </I><VAR>mode</VAR><I> parameter can be GL_FILL as well as GL_POINT or GL_LINE. GL_FILL generates filled polygons using the quad-mesh primitive. Stated precisely, <B>glEvalMesh2()</B> is nearly equivalent to one of the following three code fragments. (It's nearly equivalent because when</I><VAR> i</VAR><I> is equal to </I><VAR>nu</VAR><I> or </I><VAR>j</VAR><I> to </I><VAR>nv</VAR><I>, the parameter is exactly equal to </I><VAR>u2</VAR><I> or </I><VAR>v2</VAR><I>, not to </I><VAR>u1</VAR><I>+</I><VAR>nu</VAR><I>*(</I><VAR>u2</VAR><I>-</I><VAR>u1</VAR><I>)/</I><VAR>nu</VAR><I>, which might be slightly different due to round-off error.)</DD>
</DL>
</I><PRE>glBegin(GL_POINTS);                /* mode == GL_POINT */ <BR>
for (i = nu1; i &lt;= nu2; i++) <BR>
    for (j = nv1; j &lt;= nv2; j++) <BR>
        glEvalCoord2(u1 + i*(u2-u1)/nu, v1+j*(v2-v1)/nv);<BR>
glEnd();</PRE>
<P>or</P>
<PRE>for (i = nu1; i &lt;= nu2; i++) {     /* mode == GL_LINE */<BR>
    glBegin(GL_LINES); <BR>
        for (j = nv1; j &lt;= nv2; j++) <BR>
            glEvalCoord2(u1 + i*(u2-u1)/nu, v1+j*(v2-v1)/nv); <BR>
    glEnd(); <BR>
} <BR>
for (j = nv1; j &lt;= nv2; j++) { <BR>
    glBegin(GL_LINES); <BR>
    for (i = nu1; i &lt;= nu2; i++)  <BR>
        glEvalCoord2(u1 + i*(u2-u1)/nu, v1+j*(v2-v1)/nv); <BR>
    glEnd(); <BR>
}</PRE>
<P>or</P>
<PRE>for (i = nu1; i &lt; nu2; i++) {     /* mode == GL_FILL */ <BR>
    glBegin(GL_QUAD_STRIP);<BR>
    for (j = nv1; j &lt;= nv2; j++) { <BR>
        glEvalCoord2(u1 + i*(u2-u1)/nu, v1+j*(v2-v1)/nv);<BR>
        glEvalCoord2(u1 + (i+1)*(u2-u1)/nu, v1+j*(v2-v1)/nv);<BR>
    glEnd(); <BR>
}</PRE>
<P>Example 12-3 shows the differences necessary to draw the same Bezier surface as Example 12-2, but using <B>glMapGrid2()</B> and <B>glEvalMesh2()</B> to subdivide the square domain into a uniform 8x8 grid. This program also adds lighting and shading, as shown in Figure 12-3. </P>
<P><IMG SRC="images/Image135.gif"></P>
<B><P>Figure 12-3 : </B>Lit, Shaded Bezier Surface Drawn with a Mesh </P>

<B><P>Example 12-3 : </B>Lit, Shaded Bezier Surface Using a Mesh: bezmesh.c</P>
<PRE>void initlights(void)
{
   GLfloat ambient[] = {0.2, 0.2, 0.2, 1.0};
   GLfloat position[] = {0.0, 0.0, 2.0, 1.0};
   GLfloat mat_diffuse[] = {0.6, 0.6, 0.6, 1.0};
   GLfloat mat_specular[] = {1.0, 1.0, 1.0, 1.0};
   GLfloat mat_shininess[] = {50.0};

   glEnable(GL_LIGHTING);
   glEnable(GL_LIGHT0);

   glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
   glLightfv(GL_LIGHT0, GL_POSITION, position);

   glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
   glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
   glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);
}

void display(void)
{
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   glPushMatrix();
   glRotatef(85.0, 1.0, 1.0, 1.0);
   glEvalMesh2(GL_FILL, 0, 20, 0, 20);
   glPopMatrix();
   glFlush();
}

void init(void)
{
   glClearColor(0.0, 0.0, 0.0, 0.0);
   glEnable(GL_DEPTH_TEST);
   glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4,
           0, 1, 12, 4, &amp;ctrlpoints[0][0][0]);
   glEnable(GL_MAP2_VERTEX_3);
   glEnable(GL_AUTO_NORMAL);
   glMapGrid2f(20, 0.0, 1.0, 20, 0.0, 1.0);
   initlights();
}</PRE>
<H3>Using Evaluators for Textures </H3>
<P>Example 12-4 enables two evaluators at the same time: The first generates three-dimensional points on the same Bezier surface as Example 12-3, and the second generates texture coordinates. In this case, the texture coordinates are the same as the <VAR>u</VAR> and <VAR>v</VAR> coordinates of the surface, but a special flat Bezier patch must be created to do this. </P>
<P>The flat patch is defined over a square with corners at (0, 0), (0, 1), (1, 0), and (1, 1); it generates (0, 0) at corner (0, 0), (0, 1) at corner (0, 1), and so on. Since it's of order two (linear degree plus one), evaluating this texture at the point (<VAR>u, v</VAR>) generates texture coordinates (<VAR>s, t</VAR>). It's enabled at the same time as the vertex evaluator, so both take effect when the surface is drawn. (See <A HREF="appendixi.html#plate19">"Plate 19" in Appendix I</A>.) If you want the texture to repeat three times in each direction, change every 1.0 in the array <VAR>texpts[][][]</VAR> to 3.0. Since the texture wraps in this example, the surface is rendered with nine copies of the texture map. </P>

<B><P>Example 12-4 : </B>Using Evaluators for Textures: texturesurf.c</P>
<PRE>#include &lt;GL/gl.h&gt;
#include &lt;GL/glu.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;GL/glut.h&gt;
#include &lt;math.h&gt;

GLfloat ctrlpoints[4][4][3] = {
   {{ -1.5, -1.5, 4.0}, { -0.5, -1.5, 2.0}, 
    {0.5, -1.5, -1.0}, {1.5, -1.5, 2.0}}, 
   {{ -1.5, -0.5, 1.0}, { -0.5, -0.5, 3.0}, 
    {0.5, -0.5, 0.0}, {1.5, -0.5, -1.0}}, 
   {{ -1.5, 0.5, 4.0}, { -0.5, 0.5, 0.0}, 
    {0.5, 0.5, 3.0}, {1.5, 0.5, 4.0}}, 
   {{ -1.5, 1.5, -2.0}, { -0.5, 1.5, -2.0}, 
    {0.5, 1.5, 0.0}, {1.5, 1.5, -1.0}}
};
GLfloat texpts[2][2][2] = {{{0.0, 0.0}, {0.0, 1.0}}, 
                        {{1.0, 0.0}, {1.0, 1.0}}};

void display(void)
{
   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   glColor3f(1.0, 1.0, 1.0);
   glEvalMesh2(GL_FILL, 0, 20, 0, 20);
   glFlush();
}
#define imageWidth 64
#define imageHeight 64
GLubyte image[3*imageWidth*imageHeight];

void makeImage(void)
{
   int i, j;
   float ti, tj;
   
   for (i = 0; i &lt; imageWidth; i++) {
      ti = 2.0*3.14159265*i/imageWidth;
      for (j = 0; j &lt; imageHeight; j++) {
         tj = 2.0*3.14159265*j/imageHeight;
         image[3*(imageHeight*i+j)] = 
              (GLubyte) 127*(1.0+sin(ti));
         image[3*(imageHeight*i+j)+1] = 
              (GLubyte) 127*(1.0+cos(2*tj));
         image[3*(imageHeight*i+j)+2] = 
              (GLubyte) 127*(1.0+cos(ti+tj));
      }
   }
}

void init(void)
{
   glMap2f(GL_MAP2_VERTEX_3, 0, 1, 3, 4,
           0, 1, 12, 4, &amp;ctrlpoints[0][0][0]);
   glMap2f(GL_MAP2_TEXTURE_COORD_2, 0, 1, 2, 2, 
           0, 1, 4, 2, &amp;texpts[0][0][0]);
   glEnable(GL_MAP2_TEXTURE_COORD_2);
   glEnable(GL_MAP2_VERTEX_3);
   glMapGrid2f(20, 0.0, 1.0, 20, 0.0, 1.0);
   makeImage();
   glTexEnvf(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_DECAL);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, 
                   GL_NEAREST);
   glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, 
                   GL_NEAREST);
   glTexImage2D(GL_TEXTURE_2D, 0, 3, imageWidth, imageHeight, 0,
                GL_RGB, GL_UNSIGNED_BYTE, image);
   glEnable(GL_TEXTURE_2D);
   glEnable(GL_DEPTH_TEST);
   glShadeModel (GL_FLAT);
}

void reshape(int w, int h)
{
   glViewport(0, 0, (GLsizei) w, (GLsizei) h);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   if (w &lt;= h)
      glOrtho(-4.0, 4.0, -4.0*(GLfloat)h/(GLfloat)w, 
              4.0*(GLfloat)h/(GLfloat)w, -4.0, 4.0);
   else
      glOrtho(-4.0*(GLfloat)w/(GLfloat)h, 
              4.0*(GLfloat)w/(GLfloat)h, -4.0, 4.0, -4.0, 4.0);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
   glRotatef(85.0, 1.0, 1.0, 1.0);
}

int main(int argc, char** argv)
{
   glutInit(&amp;argc, argv);
   glutInitDisplayMode (GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);
   glutInitWindowSize (500, 500);
   glutInitWindowPosition (100, 100);
   glutCreateWindow (argv[0]);
   init ();
   glutDisplayFunc(display);
   glutReshapeFunc(reshape);
   glutMainLoop();
   return 0;
}</PRE>

<br>
<a name = name3>
<H2>The GLU NURBS Interface</H2>
<P>Although evaluators are the only OpenGL primitive available to draw curves and surfaces directly, and even though they can be implemented very efficiently in hardware, they're often accessed by applications through higher-level libraries. The GLU provides a NURBS (Non-Uniform Rational B-Spline) interface built on top of the OpenGL evaluator commands. </P>
<H3>A Simple NURBS Example</H3>
<P>If you understand NURBS, writing OpenGL code to manipulate NURBS curves and surfaces is relatively easy, even with lighting and texture mapping. Follow these steps to draw NURBS curves or untrimmed NURBS surfaces. (See <A HREF="#name4">"Trim a NURBS Surface"</A> for information about trimmed surfaces.) </P><DIR>
<DIR>

<P>If you intend to use lighting with a NURBS surface, call <B>glEnable()</B> with GL_AUTO_NORMAL to automatically generate surface normals. (Or you can calculate your own.) <BR>
</P>
<P>Use <B>gluNewNurbsRenderer()</B> to create a pointer to a NURBS object, which is referred to when creating your NURBS curve or surface.<BR>
</P>
<P>If desired, call <B>gluNurbsProperty()</B> to choose rendering values, such as the maximum size of lines or polygons that are used to render your NURBS object.<BR>
</P>
<P>Call <B>gluNurbsCallback()</B> if you want to be notified when an error is encountered. (Error checking may slightly degrade performance but is still highly recommended.)<BR>
</P>
<P>Start your curve or surface by calling <B>gluBeginCurve()</B> or <B>gluBeginSurface()</B>.<BR>
</P>
<P>Generate and render your curve or surface. Call <B>gluNurbsCurve()</B> or <B>gluNurbsSurface()</B> at least once with the control points (rational or nonrational), knot sequence, and order of the polynomial basis function for your NURBS object. You might call these functions additional times to specify surface normals and/or texture coordinates.<BR>
</P>
<P>Call <B>gluEndCurve()</B> or <B>gluEndSurface() </B>to complete the curve or surface.</P></DIR>
</DIR>

<P>Example 12-5 renders a NURBS surface in the shape of a symmetrical hill with control points ranging from -3.0 to 3.0. The basis function is a cubic B-spline, but the knot sequence is nonuniform, with a multiplicity of 4 at each endpoint, causing the basis function to behave like a Bezier curve in each direction. The surface is lighted, with a dark gray diffuse reflection and white specular highlights. Figure 12-4 shows the surface as a lit wireframe. </P>
<P><IMG SRC="images/Image136.gif"></P>
<B><P>Figure 12-4 : </B>NURBS Surface </P>

<B><P>Example 12-5 : </B>NURBS Surface: surface.c</P>
<PRE>#include &lt;GL/gl.h&gt;
#include &lt;GL/glu.h&gt;
#include &lt;GL/glut.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

GLfloat ctlpoints[4][4][3];
int showPoints = 0;

GLUnurbsObj *theNurb;

void init_surface(void)
{
   int u, v;
   for (u = 0; u &lt; 4; u++) {
      for (v = 0; v &lt; 4; v++) {
         ctlpoints[u][v][0] = 2.0*((GLfloat)u - 1.5);
         ctlpoints[u][v][1] = 2.0*((GLfloat)v - 1.5);

         if ( (u == 1 || u == 2) &amp;&amp; (v == 1 || v == 2))
            ctlpoints[u][v][2] = 3.0;
         else
            ctlpoints[u][v][2] = -3.0;
      }
   }    
}    

void nurbsError(GLenum errorCode)
{
   const GLubyte *estring;

   estring = gluErrorString(errorCode);
   fprintf (stderr, "Nurbs Error: %s\n", estring);
   exit (0);
}
   
void init(void)
{
   GLfloat mat_diffuse[] = { 0.7, 0.7, 0.7, 1.0 };
   GLfloat mat_specular[] = { 1.0, 1.0, 1.0, 1.0 };
   GLfloat mat_shininess[] = { 100.0 };

   glClearColor (0.0, 0.0, 0.0, 0.0);
   glMaterialfv(GL_FRONT, GL_DIFFUSE, mat_diffuse);
   glMaterialfv(GL_FRONT, GL_SPECULAR, mat_specular);
   glMaterialfv(GL_FRONT, GL_SHININESS, mat_shininess);

   glEnable(GL_LIGHTING);
   glEnable(GL_LIGHT0);
   glEnable(GL_DEPTH_TEST);
   glEnable(GL_AUTO_NORMAL);
   glEnable(GL_NORMALIZE);

   init_surface();

   theNurb = gluNewNurbsRenderer();
   gluNurbsProperty(theNurb, GLU_SAMPLING_TOLERANCE, 25.0);
   gluNurbsProperty(theNurb, GLU_DISPLAY_MODE, GLU_FILL);
   gluNurbsCallback(theNurb, GLU_ERROR, 
                    (GLvoid (*)()) nurbsError);
}

void display(void)
{
   GLfloat knots[8] = {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};
   int i, j;

   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

   glPushMatrix();
   glRotatef(330.0, 1.,0.,0.);
   glScalef (0.5, 0.5, 0.5);

   gluBeginSurface(theNurb);
   gluNurbsSurface(theNurb, 
                   8, knots, 8, knots,
                   4 * 3, 3, &amp;ctlpoints[0][0][0], 
                   4, 4, GL_MAP2_VERTEX_3);
   gluEndSurface(theNurb);

   if (showPoints) {
      glPointSize(5.0);
      glDisable(GL_LIGHTING);
      glColor3f(1.0, 1.0, 0.0);
      glBegin(GL_POINTS);
      for (i = 0; i &lt; 4; i++) {
         for (j = 0; j &lt; 4; j++) {
            glVertex3f(ctlpoints[i][j][0], 
                       ctlpoints[i][j][1], ctlpoints[i][j][2]);
         }
      }
      glEnd();
      glEnable(GL_LIGHTING);
   }
   glPopMatrix();
   glFlush();
}

void reshape(int w, int h)
{
   glViewport(0, 0, (GLsizei) w, (GLsizei) h);
   glMatrixMode(GL_PROJECTION);
   glLoadIdentity();
   gluPerspective (45.0, (GLdouble)w/(GLdouble)h, 3.0, 8.0);
   glMatrixMode(GL_MODELVIEW);
   glLoadIdentity();
   glTranslatef (0.0, 0.0, -5.0);
}
void keyboard(unsigned char key, int x, int y)
{
   switch (key) {
      case `c':
      case `C':
         showPoints = !showPoints;
         glutPostRedisplay();
         break;
      case 27:
         exit(0);
         break;
      default:
         break;
   }
}

int main(int argc, char** argv)
{
   glutInit(&amp;argc, argv);
   glutInitDisplayMode(GLUT_SINGLE | GLUT_RGB | GLUT_DEPTH);
   glutInitWindowSize (500, 500);
   glutInitWindowPosition (100, 100);
   glutCreateWindow(argv[0]);
   init();
   glutReshapeFunc(reshape);
   glutDisplayFunc(display);
   glutKeyboardFunc (keyboard);
   glutMainLoop();
   return 0; 
}</PRE>
<H3>Manage a NURBS Object</H3>
<P>As shown in Example 12-5, <B>gluNewNurbsRenderer()</B> returns a new NURBS object, whose type is a pointer to a GLUnurbsObj structure. You must make this object before using any other NURBS routine. When you're done with a NURBS object, you may use <B>gluDeleteNurbsRenderer()</B> to free up the memory that was used. </P>
<I><DL>
<DT>GLUnurbsObj* <B>gluNewNurbsRenderer</B> (void);</I> </DT>
<I><DD>Creates a new NURBS object, </I><VAR>nobj</VAR><I>. Returns a pointer to the new object, or zero, if OpenGL cannot allocate memory for a new NURBS object.</I> </DD>
<I><DT>void <B>gluDeleteNurbsRenderer</B> (GLUnurbsObj *</I><VAR>nobj</VAR><I>);</I> </DT>
<I><DD>Destroys the NURBS object </I><VAR>nobj</VAR><I>.</DD>
</DL>
</I><H4>Control NURBS Rendering Properties</H4>
<P>A set of properties associated with a NURBS object affects the way the object is rendered. These properties include how the surface is rasterized (for example, filled or wireframe) and the precision of tessellation. </P>
<I><DL>
<DT>void <B>gluNurbsProperty</B>(GLUnurbsObj *</I><VAR>nobj</VAR><I>, GLenum </I><VAR>property</VAR><I>, <BR>
GLfloat </I><VAR>value</VAR><I>); </DT>
<DD>Controls attributes of a NURBS object, </I><VAR>nobj</VAR><I>. The </I><VAR>property</VAR><I> argument specifies the property and can be GLU_DISPLAY_MODE, GLU_CULLING, GLU_SAMPLING_METHOD, GLU_SAMPLING_TOLERANCE, GLU_PARAMETRIC_TOLERANCE, GLU_U_STEP, GLU_V_STEP, or GLU_AUTO_LOAD_MATRIX. The </I><VAR>value</VAR><I> argument indicates what the property should be.</I> </DD>
<I><DD>The default value for GLU_DISPLAY_MODE is GLU_FILL, which causes the surface to be rendered as polygons. If GLU_OUTLINE_POLYGON is used for the display-mode property, only the outlines of polygons created by tessellation are rendered. GLU_OUTLINE_PATCH renders the outlines of patches and trimming curves. (See </I><A HREF="#name5"><I>"Create a NURBS Curve or Surface"</I></A><I>.)</I> </DD>
<I><DD>GLU_CULLING can speed up performance by not performing tessellation if the NURBS object falls completely outside the viewing volume; set this property to GL_TRUE to enable culling (the default is GL_FALSE).</I> </DD>
<I><DD>Since a NURBS object is rendered as primitives, it's sampled at different values of its parameter(s) (</I><VAR>u</VAR><I> and </I><VAR>v</VAR><I>) and broken down into small line segments or polygons for rendering. If </I><VAR>property</VAR><I> is GLU_SAMPLING_METHOD, then </I><VAR>value</VAR><I> is set to one of GLU_PATH_LENGTH (which is the default), GLU_PARAMETRIC_ERROR, or GLU_DOMAIN_DISTANCE, which specifies how a NURBS curve or surface should be tessellated. When </I><VAR>value</VAR><I> is set to GLU_PATH_LENGTH, the surface is rendered so that the maximum length, in pixels, of the edges of tessellated polygons is no greater than what is specified by GLU_SAMPLING_TOLERANCE. When set to GLU_PARAMETRIC_ERROR, then the value specified by GLU_PARAMETRIC_TOLERANCE is the maximum distance, in pixels, between tessellated polygons and the surfaces they approximate. When set to GLU_DOMAIN_DISTANCE, the application specifies, in parametric coordinates, how many sample points per unit length are taken in the </I><VAR>u</VAR><I> and </I><VAR>v</VAR><I> dimensions, using the values for GLU_U_STEP and GLU_V_STEP.</I> </DD>
<I><DD>If </I><VAR>property</VAR><I> is GLU_SAMPLING_TOLERANCE and the sampling method is GLU_PATH_LENGTH, </I><VAR>value</VAR><I> controls the maximum length, in pixels, to use for tessellated polygons. The default value of 50.0 makes the largest sampled line segment or polygon edge 50.0 pixels long. If </I><VAR>property</VAR><I> is GLU_PARAMETRIC_TOLERANCE and the sampling method is GLU_PARAMETRIC_ERROR, </I><VAR>value</VAR><I> controls the maximum distance, in pixels, between the tessellated polygons and the surfaces they approximate. The default value for GLU_PARAMETRIC_TOLERANCE is 0.5, which makes the tessellated polygons within one-half pixel of the approximated surface. If the sampling method is GLU_DOMAIN_DISTANCE and </I><VAR>property</VAR><I> is either GLU_U_STEP or GLU_V_STEP, then </I><VAR>value</VAR><I> is the number of sample points per unit length taken along the u or v dimension, respectively, in parametric coordinates. The default for both GLU_U_STEP and GLU_V_STEP is 100.</I> </DD>
<I><DD>The GLU_AUTO_LOAD_MATRIX property determines whether the projection matrix, modelview matrix, and viewport are downloaded from the OpenGL server (GL_TRUE, the default), or whether the application must supply these matrices with <B>gluLoadSamplingMatrices()</B> (GL_FALSE).</I> </DD>
<I><DT>void <B>gluLoadSamplingMatrices</B> (GLUnurbsObj *</I><VAR>nobj</VAR><I>, const GLfloat </I><VAR>modelMatrix</VAR><I>[16], const GLfloat </I><VAR>projMatrix</VAR><I>[16], const GLint </I><VAR>viewport</VAR><I>[4]);</I> </DT>
<I><DD>If the GLU_AUTO_LOAD_MATRIX is turned off, the modelview and projection matrices and the viewport specified in <B>gluLoadSamplingMatrices()</B> are used to compute sampling and culling matrices for each NURBS curve or surface.</DD>
</DL>
</I><P>If you need to query the current value for a NURBS property, you may use <B>gluGetNurbsProperty()</B>. </P>
<I><DL>
<DT>void <B>gluGetNurbsProperty </B>(GLUnurbsObj </I><VAR>*nobj</VAR><I>, GLenum </I><VAR>property</VAR><I>, <BR>
GLfloat </I><VAR>*value</VAR><I>);</I> </DT>
<I><DD>Given the </I><VAR>property</VAR><I> to be queried for the NURBS object </I><VAR>nobj</VAR><I>, return its current </I><VAR>value</VAR><I>.</DD>
</DL>
</I><H4>Handle NURBS Errors</H4>
<P>Since there are 37 different errors specific to NURBS functions, it's a good idea to register an error callback to let you know if you've stumbled into one of them. In Example 12-5, the callback function was registered with</P>
<PRE>gluNurbsCallback(theNurb, GLU_ERROR, (GLvoid (*)()) nurbsError);</PRE>
<I><DL>
<DT>void <B>gluNurbsCallback</B> (GLUnurbsObj *</I><VAR>nobj</VAR><I>, GLenum </I><VAR>which</VAR><I>, <BR>
void (*</I><VAR>fn</VAR><I>)(GLenum </I><VAR>errorCode</VAR><I>));</I> </DT>
<VAR><DD>which</VAR><I> is the type of callback; it must be GLU_ERROR. When a NURBS function detects an error condition, </I><VAR>fn</VAR><I> is invoked with the error code as its only argument. </I><VAR>errorCode</VAR><I> is one of 37 error conditions, named GLU_NURBS_ERROR1 through GLU_NURBS_ERROR37. Use <B>gluErrorString()</B> to describe the meaning of those error codes.</DD>
</DL>
</I><P>In Example 12-5, the <B>nurbsError()</B> routine was registered as the error callback function:</P>
<PRE>void nurbsError(GLenum errorCode)
{
   const GLubyte *estring;

   estring = gluErrorString(errorCode);
   fprintf (stderr, "Nurbs Error: %s\n", estring);
   exit (0);
}</PRE>

<a name = name5>
<H3>Create a NURBS Curve or Surface</H3>
<P>To render a NURBS surface, <B>gluNurbsSurface()</B> is bracketed by <B>gluBeginSurface()</B> and <B>gluEndSurface()</B>. The bracketing routines save and restore the evaluator state. </P>
<I><DL>
<DT>void <B>gluBeginSurface</B> (GLUnurbsObj *nobj);<BR>
void <B>gluEndSurface</B> (GLUnurbsObj *nobj);</I> </DT>
<I><DD>After <B>gluBeginSurface()</B>, one or more calls to <B>gluNurbsSurface()</B> defines the attributes of the surface. Exactly one of these calls must have a surface type of GL_MAP2_VERTEX_3 or GL_MAP2_VERTEX_4 to generate vertices. Use <B>gluEndSurface()</B> to end the definition of a surface. Trimming of NURBS surfaces is also supported between <B>gluBeginSurface()</B> and <B>gluEndSurface().</B> (See </I><A HREF="#name4"><I>"Trim a NURBS Surface"</I></A><I>.)</I> </DD>
<I><DT>void <B>gluNurbsSurface</B> (GLUnurbsObj *</I><VAR>nobj</VAR><I>, GLint </I><VAR>uknot_count</VAR><I>, <BR>
GLfloat *</I><VAR>uknot</VAR><I>, GLint </I><VAR>vknot_count</VAR><I>, GLfloat *</I><VAR>vknot</VAR><I>, <BR>
GLint </I><VAR>u_stride</VAR><I>, GLint </I><VAR>v_stride</VAR><I>, GLfloat *</I><VAR>ctlarray</VAR><I>, <BR>
GLint </I><VAR>uorder</VAR><I>, GLint </I><VAR>vorder</VAR><I>, GLenum </I><VAR>type</VAR><I>); </DT>
<DD>Describes the vertices (or surface normals or texture coordinates) of a NURBS surface, </I><VAR>nobj</VAR><I>. Several of the values must be specified for both </I><VAR>u</VAR><I> and </I><VAR>v</VAR><I> parametric directions, such as the knot sequences (</I><VAR>uknot</VAR><I> and </I><VAR>vknot</VAR><I>), knot counts (</I><VAR>uknot_count</VAR><I> and </I><VAR>vknot_count</VAR><I>), and order of the polynomial (</I><VAR>uorder</VAR><I> and </I><VAR>vorder</VAR><I>) for the NURBS surface. Note that the number of control points isn't specified. Instead, it's derived by determining the number of control points along each parameter as the number of knots minus the order. Then, the number of control points for the surface is equal to the number of control points in each parametric direction, multiplied by one another. The </I><VAR>ctlarray</VAR><I> argument points to an array of control points.</I> </DD>
<I><DD>The last parameter, </I><VAR>type</VAR><I>, is one of the two-dimensional evaluator types. Commonly, you might use GL_MAP2_VERTEX_3 for nonrational or GL_MAP2_VERTEX_4 for rational control points, respectively. You might also use other types, such as GL_MAP2_TEXTURE_COORD_* or GL_MAP2_NORMAL to calculate and assign texture coordinates or surface normals. For example, to create a lighted (with surface normals) and textured NURBS surface, you may need to call this sequence:</DD>
</DL>
</I><PRE>gluBeginSurface(nobj);
   gluNurbsSurface(nobj, ..., GL_MAP2_TEXTURE_COORD_2);
   gluNurbsSurface(nobj, ..., GL_MAP2_NORMAL);
   gluNurbsSurface(nobj, ..., GL_MAP2_VERTEX_3);
gluEndSurface(nobj);</PRE>
<I><DL>
<DD>The </I><VAR>u_stride</VAR><I> and </I><VAR>v_stride</VAR><I> arguments represent the number of floating-point values between control points in each parametric direction. The evaluator type, as well as its order, affects the </I><VAR>u_stride</VAR><I> and </I><VAR>v_stride</VAR><I> values. In </I><I>Example 12-5</I><I>, </I><VAR>u_stride</VAR><I> is 12 (4 * 3) because there are three coordinates for each vertex (set by GL_MAP2_VERTEX_3) and four control points in the parametric </I><VAR>v</VAR><I> direction; </I><VAR>v_stride</VAR><I> is 3 because each vertex had three coordinates, and </I><VAR>v</VAR><I> control points are adjacent to one another.</DD>
</DL>
</I><P>Drawing a NURBS curve is similar to drawing a surface, except that all calculations are done with one parameter, <VAR>u</VAR>, rather than two. Also, for curves, <B>gluBeginCurve()</B> and <B>gluEndCurve()</B> are the bracketing routines. </P>
<I><DL>
<DT>void <B>gluBeginCurve</B> (GLUnurbsObj </I><VAR>*nobj</VAR><I>);<BR>
void <B>gluEndCurve</B> (GLUnurbsObj </I><VAR>*nobj</VAR><I>);</I> </DT>
<I><DD>After <B>gluBeginCurve()</B>, one or more calls to <B>gluNurbsCurve()</B> define the attributes of the surface. Exactly one of these calls must have a surface type of GL_MAP1_VERTEX_3 or GL_MAP1_VERTEX_4 to generate vertices. Use <B>gluEndCurve()</B> to end the definition of a surface. </DD>
<DT>void <B>gluNurbsCurve</B> (GLUnurbsObj *</I><VAR>nobj</VAR><I>, GLint </I><VAR>uknot_count</VAR><I>, <BR>
GLfloat *</I><VAR>uknot</VAR><I>, GLint </I><VAR>u_stride</VAR><I>, GLfloat *</I><VAR>ctlarray</VAR><I>, <BR>
GLint </I><VAR>uorder</VAR><I>, GLenum </I><VAR>type</VAR><I>);</I> </DT>
<I><DD>Defines a NURBS curve for the object </I><VAR>nobj</VAR><I>. The arguments have the same meaning as those for <B>gluNurbsSurface()</B>. Note that this routine requires only one knot sequence and one declaration of the order of the NURBS object. If this curve is defined within a <B>gluBeginCurve()/gluEndCurve()</B> pair, then the type can be any of the valid one-dimensional evaluator types (such as GL_MAP1_VERTEX_3 or GL_MAP1_VERTEX_4). </DD>
</DL>
</I>

<a name = name4>
<H3>Trim a NURBS Surface</H3>
<P>To create a trimmed NURBS surface with OpenGL, start as if you were creating an untrimmed surface. After calling <B>gluBeginSurface()</B> and <B>gluNurbsSurface()</B> but before calling <B>gluEndSurface()</B>, start a trim by calling <B>gluBeginTrim()</B>. </P>
<I><DL>
<DT>void <B>gluBeginTrim</B> (GLUnurbsObj *</I><VAR>nobj</VAR><I>);<BR>
void <B>gluEndTrim</B> (GLUnurbsObj *</I><VAR>nobj</VAR><I>);</I> </DT>
<I><DD>Marks the beginning and end of the definition of a trimming loop. A trimming loop is a set of oriented, trimming curve segments (forming a closed curve) that defines the boundaries of a NURBS surface.</DD>
</DL>
</I><P>You can create two kinds of trimming curves, a piecewise linear curve with <B>gluPwlCurve()</B> or a NURBS curve with <B>gluNurbsCurve()</B>. A piecewise linear curve doesn't look like what's conventionally called a curve, because it's a series of straight lines. A NURBS curve for trimming must lie within the unit square of parametric (<VAR>u</VAR>,<VAR> v</VAR>) space. The type for a NURBS trimming curve is usually GLU_MAP1_TRIM2. Less often, the type is GLU_MAP1_TRIM3, where the curve is described in a two-dimensional homogeneous space (<VAR>u', v', w</VAR>') by (<VAR>u, v</VAR>) = (<VAR>u'/w</VAR>', <VAR>v'/w</VAR>'). </P>
<I><DL>
<DT>void <B>gluPwlCurve</B> (GLUnurbsObj *</I><VAR>nobj</VAR><I>, GLint </I><VAR>count</VAR><I>, GLfloat *</I><VAR>array</VAR><I>, <BR>
GLint </I><VAR>stride</VAR><I>, GLenum </I><VAR>type</VAR><I>); </DT>
<DD>Describes a piecewise linear trimming curve for the NURBS object </I><VAR>nobj</VAR><I>. There are </I><VAR>count</VAR><I> points on the curve, and they're given by </I><VAR>array</VAR><I>. The </I><VAR>type</VAR><I> can be either GLU_MAP1_TRIM_2 (the most common) or GLU_MAP1_TRIM_3 ((</I><VAR>u, v, w</VAR><I>) homogeneous parameter space). The type affects whether </I><VAR>stride</VAR><I>, the number of floating-point values to the next vertex, is 2 or 3.</DD>
</DL>
</I><P>You need to consider the orientation of trimming curves - that is, whether they're counterclockwise or clockwise - to make sure you include the desired part of the surface. If you imagine walking along a curve, everything to the left is included and everything to the right is trimmed away. For example, if your trim consists of a single counterclockwise loop, everything inside the loop is included. If the trim consists of two nonintersecting counterclockwise loops with nonintersecting interiors, everything inside either of them is included. If it consists of a counterclockwise loop with two clockwise loops inside it, the trimming region has two holes in it. The outermost trimming curve must be counterclockwise. Often, you run a trimming curve around the entire unit square to include everything within it, which is what you get by default by not specifying any trimming curves. </P>
<P>Trimming curves must be closed and nonintersecting. You can combine trimming curves, so long as the endpoints of the trimming curves meet to form a closed curve. You can nest curves, creating islands that float in space. Be sure to get the curve orientations right. For example, an error results if you specify a trimming region with two counterclockwise curves, one enclosed within another: The region between the curves is to the left of one and to the right of the other, so it must be both included and excluded, which is impossible. Figure 12-5 illustrates a few valid possibilities. </P>
<P><IMG SRC="images/Image137.gif"></P>
<B><P>Figure 12-5 : </B>Parametric Trimming Curves </P>

<P>Figure 12-6 shows the same small hill as in Figure 12-4, this time with a trimming curve that's a combination of a piecewise linear curve and a NURBS curve. The program that creates this figure is similar to that shown in Example 12-5; the differences are in the routines shown in Example 12-6. </P>
<P><IMG SRC="images/Image138.gif"></P>
<B><P>Figure 12-6 : </B>Trimmed NURBS Surface </P>

<B><P>Example 12-6 : </B>Trimming a NURBS Surface: trim.c</P>
<PRE>void display(void)
{
   GLfloat knots[8] = {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};
   GLfloat edgePt[5][2] = /* counter clockwise */
      {{0.0, 0.0}, {1.0, 0.0}, {1.0, 1.0}, {0.0, 1.0}, 
       {0.0, 0.0}};
   GLfloat curvePt[4][2] = /* clockwise */ 
      {{0.25, 0.5}, {0.25, 0.75}, {0.75, 0.75}, {0.75, 0.5}};
   GLfloat curveKnots[8] = 
      {0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 1.0};
   GLfloat pwlPt[4][2] = /* clockwise */ 
      {{0.75, 0.5}, {0.5, 0.25}, {0.25, 0.5}};

   glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
   glPushMatrix();
   glRotatef(330.0, 1.,0.,0.);
   glScalef (0.5, 0.5, 0.5);

   gluBeginSurface(theNurb);
   gluNurbsSurface(theNurb, 8, knots, 8, knots,
                   4 * 3, 3, &amp;ctlpoints[0][0][0], 
                   4, 4, GL_MAP2_VERTEX_3);
   gluBeginTrim (theNurb);
      gluPwlCurve (theNurb, 5, &amp;edgePt[0][0], 2,
                   GLU_MAP1_TRIM_2);
   gluEndTrim (theNurb);
   gluBeginTrim (theNurb);
      gluNurbsCurve (theNurb, 8, curveKnots, 2, 
                     &amp;curvePt[0][0], 4, GLU_MAP1_TRIM_2);
      gluPwlCurve (theNurb, 3, &amp;pwlPt[0][0], 2,
                   GLU_MAP1_TRIM_2);
   gluEndTrim (theNurb);
   gluEndSurface(theNurb);
        
   glPopMatrix();
   glFlush();
}
</PRE>
<P>In Example 12-6, <B>gluBeginTrim()</B> and <B>gluEndTrim()</B> bracket each trimming curve. The first trim, with vertices defined by the array <VAR>edgePt[][]</VAR>, goes counterclockwise around the entire unit square of parametric space. This ensures that everything is drawn, provided it isn't removed by a clockwise trimming curve inside of it. The second trim is a combination of a NURBS trimming curve and a piecewise linear trimming curve. The NURBS curve ends at the points (0.9, 0.5) and (0.1, 0.5), where it is met by the piecewise linear curve, forming a closed clockwise curve. </P>

<hr size="1" noshade style="color:#226666;">
<center>
<A HREF="chapter11.html"><img src="images/ArrowLeft.gif" border=0></A>
<a href="index.html"><img src="images/ArrowHome.gif" border=0></a>
<A HREF="chapter13.html"><img src="images/ArrowRight.gif" border=0></A>
</center>

</td></tr>
</table>
</div>

</BODY>
</HTML>

